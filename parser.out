Grammar:

Rule 0     S' -> program
Rule 1     program -> stmt_list
Rule 2     stmt_list -> stmt
Rule 3     stmt_list -> stmt_list stmt
Rule 4     stmt -> RETURN expr ;
Rule 5     stmt -> CONTINUE ;
Rule 6     stmt -> BREAK ;
Rule 7     stmt -> FOR ID = expr : expr stmt
Rule 8     stmt -> WHILE ( expr ) stmt
Rule 9     stmt -> IF ( expr ) stmt  [precedence=nonassoc, level=1]
Rule 10    stmt -> IF ( expr ) stmt ELSE stmt  [precedence=nonassoc, level=2]
Rule 11    stmt -> PRINT expr_list ;
Rule 12    stmt -> expr DIVASSIGN expr ;
Rule 13    stmt -> expr MULASSIGN expr ;
Rule 14    stmt -> expr SUBASSIGN expr ;
Rule 15    stmt -> expr ADDASSIGN expr ;
Rule 16    stmt -> expr = expr ;
Rule 17    stmt -> expr ;
Rule 18    stmt -> { }
Rule 19    stmt -> { stmt_list }
Rule 20    expr_list -> expr
Rule 21    expr_list -> expr , expr_list
Rule 22    expr -> ( expr )
Rule 23    expr -> EYE ( expr_list )
Rule 24    expr -> ONES ( expr_list )
Rule 25    expr -> ZEROS ( expr_list )
Rule 26    expr -> ID
Rule 27    expr -> STRING
Rule 28    expr -> FLOAT
Rule 29    expr -> INT
Rule 30    expr -> expr '
Rule 31    expr -> - expr  [precedence=left, level=5]
Rule 32    expr -> expr GEQ expr  [precedence=nonassoc, level=3]
Rule 33    expr -> expr LEQ expr  [precedence=nonassoc, level=3]
Rule 34    expr -> expr > expr  [precedence=nonassoc, level=3]
Rule 35    expr -> expr < expr  [precedence=nonassoc, level=3]
Rule 36    expr -> expr NEQ expr  [precedence=nonassoc, level=3]
Rule 37    expr -> expr EQ expr  [precedence=nonassoc, level=3]
Rule 38    expr -> expr DOTDIV expr  [precedence=left, level=5]
Rule 39    expr -> expr DOTMUL expr  [precedence=left, level=5]
Rule 40    expr -> expr DOTSUB expr  [precedence=left, level=4]
Rule 41    expr -> expr DOTADD expr  [precedence=left, level=4]
Rule 42    expr -> expr / expr  [precedence=left, level=5]
Rule 43    expr -> expr * expr  [precedence=left, level=5]
Rule 44    expr -> expr - expr  [precedence=left, level=4]
Rule 45    expr -> expr + expr  [precedence=left, level=4]
Rule 46    expr -> [ expr_list ]
Rule 47    expr -> expr [ expr_list ]

Terminals, with rules where they appear:

'                    : 30
(                    : 8 9 10 22 23 24 25
)                    : 8 9 10 22 23 24 25
*                    : 43
+                    : 45
,                    : 21
-                    : 31 44
/                    : 42
:                    : 7
;                    : 4 5 6 11 12 13 14 15 16 17
<                    : 35
=                    : 7 16
>                    : 34
ADDASSIGN            : 15
BREAK                : 6
CONTINUE             : 5
DIVASSIGN            : 12
DOTADD               : 41
DOTDIV               : 38
DOTMUL               : 39
DOTSUB               : 40
ELSE                 : 10
EQ                   : 37
EYE                  : 23
FLOAT                : 28
FOR                  : 7
GEQ                  : 32
ID                   : 7 26
IF                   : 9 10
INT                  : 29
LEQ                  : 33
MULASSIGN            : 13
NEQ                  : 36
ONES                 : 24
PRINT                : 11
RETURN               : 4
STRING               : 27
SUBASSIGN            : 14
WHILE                : 8
ZEROS                : 25
[                    : 46 47
]                    : 46 47
error                : 
{                    : 18 19
}                    : 18 19

Nonterminals, with rules where they appear:

expr                 : 4 7 7 8 9 10 12 12 13 13 14 14 15 15 16 16 17 20 21 22 30 31 32 32 33 33 34 34 35 35 36 36 37 37 38 38 39 39 40 40 41 41 42 42 43 43 44 44 45 45 47
expr_list            : 11 21 23 24 25 46 47
program              : 0
stmt                 : 2 3 7 8 9 10 10
stmt_list            : 1 3 19


state 0

    (0) S' -> . program
    (1) program -> . stmt_list
    (2) stmt_list -> . stmt
    (3) stmt_list -> . stmt_list stmt
    (4) stmt -> . RETURN expr ;
    (5) stmt -> . CONTINUE ;
    (6) stmt -> . BREAK ;
    (7) stmt -> . FOR ID = expr : expr stmt
    (8) stmt -> . WHILE ( expr ) stmt
    (9) stmt -> . IF ( expr ) stmt
    (10) stmt -> . IF ( expr ) stmt ELSE stmt
    (11) stmt -> . PRINT expr_list ;
    (12) stmt -> . expr DIVASSIGN expr ;
    (13) stmt -> . expr MULASSIGN expr ;
    (14) stmt -> . expr SUBASSIGN expr ;
    (15) stmt -> . expr ADDASSIGN expr ;
    (16) stmt -> . expr = expr ;
    (17) stmt -> . expr ;
    (18) stmt -> . { }
    (19) stmt -> . { stmt_list }
    (22) expr -> . ( expr )
    (23) expr -> . EYE ( expr_list )
    (24) expr -> . ONES ( expr_list )
    (25) expr -> . ZEROS ( expr_list )
    (26) expr -> . ID
    (27) expr -> . STRING
    (28) expr -> . FLOAT
    (29) expr -> . INT
    (30) expr -> . expr '
    (31) expr -> . - expr
    (32) expr -> . expr GEQ expr
    (33) expr -> . expr LEQ expr
    (34) expr -> . expr > expr
    (35) expr -> . expr < expr
    (36) expr -> . expr NEQ expr
    (37) expr -> . expr EQ expr
    (38) expr -> . expr DOTDIV expr
    (39) expr -> . expr DOTMUL expr
    (40) expr -> . expr DOTSUB expr
    (41) expr -> . expr DOTADD expr
    (42) expr -> . expr / expr
    (43) expr -> . expr * expr
    (44) expr -> . expr - expr
    (45) expr -> . expr + expr
    (46) expr -> . [ expr_list ]
    (47) expr -> . expr [ expr_list ]
    RETURN          shift and go to state 4
    CONTINUE        shift and go to state 6
    BREAK           shift and go to state 7
    FOR             shift and go to state 8
    WHILE           shift and go to state 10
    IF              shift and go to state 12
    PRINT           shift and go to state 13
    {               shift and go to state 14
    (               shift and go to state 11
    EYE             shift and go to state 15
    ONES            shift and go to state 16
    ZEROS           shift and go to state 17
    ID              shift and go to state 9
    STRING          shift and go to state 18
    FLOAT           shift and go to state 19
    INT             shift and go to state 20
    -               shift and go to state 21
    [               shift and go to state 22

    program                        shift and go to state 1
    stmt_list                      shift and go to state 2
    stmt                           shift and go to state 3
    expr                           shift and go to state 5

state 1

    (0) S' -> program .


state 2

    (1) program -> stmt_list .
    (3) stmt_list -> stmt_list . stmt
    (4) stmt -> . RETURN expr ;
    (5) stmt -> . CONTINUE ;
    (6) stmt -> . BREAK ;
    (7) stmt -> . FOR ID = expr : expr stmt
    (8) stmt -> . WHILE ( expr ) stmt
    (9) stmt -> . IF ( expr ) stmt
    (10) stmt -> . IF ( expr ) stmt ELSE stmt
    (11) stmt -> . PRINT expr_list ;
    (12) stmt -> . expr DIVASSIGN expr ;
    (13) stmt -> . expr MULASSIGN expr ;
    (14) stmt -> . expr SUBASSIGN expr ;
    (15) stmt -> . expr ADDASSIGN expr ;
    (16) stmt -> . expr = expr ;
    (17) stmt -> . expr ;
    (18) stmt -> . { }
    (19) stmt -> . { stmt_list }
    (22) expr -> . ( expr )
    (23) expr -> . EYE ( expr_list )
    (24) expr -> . ONES ( expr_list )
    (25) expr -> . ZEROS ( expr_list )
    (26) expr -> . ID
    (27) expr -> . STRING
    (28) expr -> . FLOAT
    (29) expr -> . INT
    (30) expr -> . expr '
    (31) expr -> . - expr
    (32) expr -> . expr GEQ expr
    (33) expr -> . expr LEQ expr
    (34) expr -> . expr > expr
    (35) expr -> . expr < expr
    (36) expr -> . expr NEQ expr
    (37) expr -> . expr EQ expr
    (38) expr -> . expr DOTDIV expr
    (39) expr -> . expr DOTMUL expr
    (40) expr -> . expr DOTSUB expr
    (41) expr -> . expr DOTADD expr
    (42) expr -> . expr / expr
    (43) expr -> . expr * expr
    (44) expr -> . expr - expr
    (45) expr -> . expr + expr
    (46) expr -> . [ expr_list ]
    (47) expr -> . expr [ expr_list ]
    $end            reduce using rule 1 (program -> stmt_list .)
    RETURN          shift and go to state 4
    CONTINUE        shift and go to state 6
    BREAK           shift and go to state 7
    FOR             shift and go to state 8
    WHILE           shift and go to state 10
    IF              shift and go to state 12
    PRINT           shift and go to state 13
    {               shift and go to state 14
    (               shift and go to state 11
    EYE             shift and go to state 15
    ONES            shift and go to state 16
    ZEROS           shift and go to state 17
    ID              shift and go to state 9
    STRING          shift and go to state 18
    FLOAT           shift and go to state 19
    INT             shift and go to state 20
    -               shift and go to state 21
    [               shift and go to state 22

    stmt                           shift and go to state 23
    expr                           shift and go to state 5

state 3

    (2) stmt_list -> stmt .
    RETURN          reduce using rule 2 (stmt_list -> stmt .)
    CONTINUE        reduce using rule 2 (stmt_list -> stmt .)
    BREAK           reduce using rule 2 (stmt_list -> stmt .)
    FOR             reduce using rule 2 (stmt_list -> stmt .)
    WHILE           reduce using rule 2 (stmt_list -> stmt .)
    IF              reduce using rule 2 (stmt_list -> stmt .)
    PRINT           reduce using rule 2 (stmt_list -> stmt .)
    {               reduce using rule 2 (stmt_list -> stmt .)
    (               reduce using rule 2 (stmt_list -> stmt .)
    EYE             reduce using rule 2 (stmt_list -> stmt .)
    ONES            reduce using rule 2 (stmt_list -> stmt .)
    ZEROS           reduce using rule 2 (stmt_list -> stmt .)
    ID              reduce using rule 2 (stmt_list -> stmt .)
    STRING          reduce using rule 2 (stmt_list -> stmt .)
    FLOAT           reduce using rule 2 (stmt_list -> stmt .)
    INT             reduce using rule 2 (stmt_list -> stmt .)
    -               reduce using rule 2 (stmt_list -> stmt .)
    [               reduce using rule 2 (stmt_list -> stmt .)
    $end            reduce using rule 2 (stmt_list -> stmt .)
    }               reduce using rule 2 (stmt_list -> stmt .)


state 4

    (4) stmt -> RETURN . expr ;
    (22) expr -> . ( expr )
    (23) expr -> . EYE ( expr_list )
    (24) expr -> . ONES ( expr_list )
    (25) expr -> . ZEROS ( expr_list )
    (26) expr -> . ID
    (27) expr -> . STRING
    (28) expr -> . FLOAT
    (29) expr -> . INT
    (30) expr -> . expr '
    (31) expr -> . - expr
    (32) expr -> . expr GEQ expr
    (33) expr -> . expr LEQ expr
    (34) expr -> . expr > expr
    (35) expr -> . expr < expr
    (36) expr -> . expr NEQ expr
    (37) expr -> . expr EQ expr
    (38) expr -> . expr DOTDIV expr
    (39) expr -> . expr DOTMUL expr
    (40) expr -> . expr DOTSUB expr
    (41) expr -> . expr DOTADD expr
    (42) expr -> . expr / expr
    (43) expr -> . expr * expr
    (44) expr -> . expr - expr
    (45) expr -> . expr + expr
    (46) expr -> . [ expr_list ]
    (47) expr -> . expr [ expr_list ]
    (               shift and go to state 11
    EYE             shift and go to state 15
    ONES            shift and go to state 16
    ZEROS           shift and go to state 17
    ID              shift and go to state 9
    STRING          shift and go to state 18
    FLOAT           shift and go to state 19
    INT             shift and go to state 20
    -               shift and go to state 21
    [               shift and go to state 22

    expr                           shift and go to state 24

state 5

    (12) stmt -> expr . DIVASSIGN expr ;
    (13) stmt -> expr . MULASSIGN expr ;
    (14) stmt -> expr . SUBASSIGN expr ;
    (15) stmt -> expr . ADDASSIGN expr ;
    (16) stmt -> expr . = expr ;
    (17) stmt -> expr . ;
    (30) expr -> expr . '
    (32) expr -> expr . GEQ expr
    (33) expr -> expr . LEQ expr
    (34) expr -> expr . > expr
    (35) expr -> expr . < expr
    (36) expr -> expr . NEQ expr
    (37) expr -> expr . EQ expr
    (38) expr -> expr . DOTDIV expr
    (39) expr -> expr . DOTMUL expr
    (40) expr -> expr . DOTSUB expr
    (41) expr -> expr . DOTADD expr
    (42) expr -> expr . / expr
    (43) expr -> expr . * expr
    (44) expr -> expr . - expr
    (45) expr -> expr . + expr
    (47) expr -> expr . [ expr_list ]
    DIVASSIGN       shift and go to state 25
    MULASSIGN       shift and go to state 27
    SUBASSIGN       shift and go to state 28
    ADDASSIGN       shift and go to state 29
    =               shift and go to state 30
    ;               shift and go to state 26
    '               shift and go to state 31
    GEQ             shift and go to state 32
    LEQ             shift and go to state 33
    >               shift and go to state 34
    <               shift and go to state 35
    NEQ             shift and go to state 36
    EQ              shift and go to state 37
    DOTDIV          shift and go to state 38
    DOTMUL          shift and go to state 39
    DOTSUB          shift and go to state 40
    DOTADD          shift and go to state 41
    /               shift and go to state 42
    *               shift and go to state 43
    -               shift and go to state 44
    +               shift and go to state 45
    [               shift and go to state 46


state 6

    (5) stmt -> CONTINUE . ;
    ;               shift and go to state 47


state 7

    (6) stmt -> BREAK . ;
    ;               shift and go to state 48


state 8

    (7) stmt -> FOR . ID = expr : expr stmt
    ID              shift and go to state 49


state 9

    (26) expr -> ID .
    DIVASSIGN       reduce using rule 26 (expr -> ID .)
    MULASSIGN       reduce using rule 26 (expr -> ID .)
    SUBASSIGN       reduce using rule 26 (expr -> ID .)
    ADDASSIGN       reduce using rule 26 (expr -> ID .)
    =               reduce using rule 26 (expr -> ID .)
    ;               reduce using rule 26 (expr -> ID .)
    '               reduce using rule 26 (expr -> ID .)
    GEQ             reduce using rule 26 (expr -> ID .)
    LEQ             reduce using rule 26 (expr -> ID .)
    >               reduce using rule 26 (expr -> ID .)
    <               reduce using rule 26 (expr -> ID .)
    NEQ             reduce using rule 26 (expr -> ID .)
    EQ              reduce using rule 26 (expr -> ID .)
    DOTDIV          reduce using rule 26 (expr -> ID .)
    DOTMUL          reduce using rule 26 (expr -> ID .)
    DOTSUB          reduce using rule 26 (expr -> ID .)
    DOTADD          reduce using rule 26 (expr -> ID .)
    /               reduce using rule 26 (expr -> ID .)
    *               reduce using rule 26 (expr -> ID .)
    -               reduce using rule 26 (expr -> ID .)
    +               reduce using rule 26 (expr -> ID .)
    [               reduce using rule 26 (expr -> ID .)
    )               reduce using rule 26 (expr -> ID .)
    ,               reduce using rule 26 (expr -> ID .)
    ]               reduce using rule 26 (expr -> ID .)
    :               reduce using rule 26 (expr -> ID .)
    RETURN          reduce using rule 26 (expr -> ID .)
    CONTINUE        reduce using rule 26 (expr -> ID .)
    BREAK           reduce using rule 26 (expr -> ID .)
    FOR             reduce using rule 26 (expr -> ID .)
    WHILE           reduce using rule 26 (expr -> ID .)
    IF              reduce using rule 26 (expr -> ID .)
    PRINT           reduce using rule 26 (expr -> ID .)
    {               reduce using rule 26 (expr -> ID .)
    (               reduce using rule 26 (expr -> ID .)
    EYE             reduce using rule 26 (expr -> ID .)
    ONES            reduce using rule 26 (expr -> ID .)
    ZEROS           reduce using rule 26 (expr -> ID .)
    ID              reduce using rule 26 (expr -> ID .)
    STRING          reduce using rule 26 (expr -> ID .)
    FLOAT           reduce using rule 26 (expr -> ID .)
    INT             reduce using rule 26 (expr -> ID .)


state 10

    (8) stmt -> WHILE . ( expr ) stmt
    (               shift and go to state 50


state 11

    (22) expr -> ( . expr )
    (22) expr -> . ( expr )
    (23) expr -> . EYE ( expr_list )
    (24) expr -> . ONES ( expr_list )
    (25) expr -> . ZEROS ( expr_list )
    (26) expr -> . ID
    (27) expr -> . STRING
    (28) expr -> . FLOAT
    (29) expr -> . INT
    (30) expr -> . expr '
    (31) expr -> . - expr
    (32) expr -> . expr GEQ expr
    (33) expr -> . expr LEQ expr
    (34) expr -> . expr > expr
    (35) expr -> . expr < expr
    (36) expr -> . expr NEQ expr
    (37) expr -> . expr EQ expr
    (38) expr -> . expr DOTDIV expr
    (39) expr -> . expr DOTMUL expr
    (40) expr -> . expr DOTSUB expr
    (41) expr -> . expr DOTADD expr
    (42) expr -> . expr / expr
    (43) expr -> . expr * expr
    (44) expr -> . expr - expr
    (45) expr -> . expr + expr
    (46) expr -> . [ expr_list ]
    (47) expr -> . expr [ expr_list ]
    (               shift and go to state 11
    EYE             shift and go to state 15
    ONES            shift and go to state 16
    ZEROS           shift and go to state 17
    ID              shift and go to state 9
    STRING          shift and go to state 18
    FLOAT           shift and go to state 19
    INT             shift and go to state 20
    -               shift and go to state 21
    [               shift and go to state 22

    expr                           shift and go to state 51

state 12

    (9) stmt -> IF . ( expr ) stmt
    (10) stmt -> IF . ( expr ) stmt ELSE stmt
    (               shift and go to state 52


state 13

    (11) stmt -> PRINT . expr_list ;
    (20) expr_list -> . expr
    (21) expr_list -> . expr , expr_list
    (22) expr -> . ( expr )
    (23) expr -> . EYE ( expr_list )
    (24) expr -> . ONES ( expr_list )
    (25) expr -> . ZEROS ( expr_list )
    (26) expr -> . ID
    (27) expr -> . STRING
    (28) expr -> . FLOAT
    (29) expr -> . INT
    (30) expr -> . expr '
    (31) expr -> . - expr
    (32) expr -> . expr GEQ expr
    (33) expr -> . expr LEQ expr
    (34) expr -> . expr > expr
    (35) expr -> . expr < expr
    (36) expr -> . expr NEQ expr
    (37) expr -> . expr EQ expr
    (38) expr -> . expr DOTDIV expr
    (39) expr -> . expr DOTMUL expr
    (40) expr -> . expr DOTSUB expr
    (41) expr -> . expr DOTADD expr
    (42) expr -> . expr / expr
    (43) expr -> . expr * expr
    (44) expr -> . expr - expr
    (45) expr -> . expr + expr
    (46) expr -> . [ expr_list ]
    (47) expr -> . expr [ expr_list ]
    (               shift and go to state 11
    EYE             shift and go to state 15
    ONES            shift and go to state 16
    ZEROS           shift and go to state 17
    ID              shift and go to state 9
    STRING          shift and go to state 18
    FLOAT           shift and go to state 19
    INT             shift and go to state 20
    -               shift and go to state 21
    [               shift and go to state 22

    expr_list                      shift and go to state 53
    expr                           shift and go to state 54

state 14

    (18) stmt -> { . }
    (19) stmt -> { . stmt_list }
    (2) stmt_list -> . stmt
    (3) stmt_list -> . stmt_list stmt
    (4) stmt -> . RETURN expr ;
    (5) stmt -> . CONTINUE ;
    (6) stmt -> . BREAK ;
    (7) stmt -> . FOR ID = expr : expr stmt
    (8) stmt -> . WHILE ( expr ) stmt
    (9) stmt -> . IF ( expr ) stmt
    (10) stmt -> . IF ( expr ) stmt ELSE stmt
    (11) stmt -> . PRINT expr_list ;
    (12) stmt -> . expr DIVASSIGN expr ;
    (13) stmt -> . expr MULASSIGN expr ;
    (14) stmt -> . expr SUBASSIGN expr ;
    (15) stmt -> . expr ADDASSIGN expr ;
    (16) stmt -> . expr = expr ;
    (17) stmt -> . expr ;
    (18) stmt -> . { }
    (19) stmt -> . { stmt_list }
    (22) expr -> . ( expr )
    (23) expr -> . EYE ( expr_list )
    (24) expr -> . ONES ( expr_list )
    (25) expr -> . ZEROS ( expr_list )
    (26) expr -> . ID
    (27) expr -> . STRING
    (28) expr -> . FLOAT
    (29) expr -> . INT
    (30) expr -> . expr '
    (31) expr -> . - expr
    (32) expr -> . expr GEQ expr
    (33) expr -> . expr LEQ expr
    (34) expr -> . expr > expr
    (35) expr -> . expr < expr
    (36) expr -> . expr NEQ expr
    (37) expr -> . expr EQ expr
    (38) expr -> . expr DOTDIV expr
    (39) expr -> . expr DOTMUL expr
    (40) expr -> . expr DOTSUB expr
    (41) expr -> . expr DOTADD expr
    (42) expr -> . expr / expr
    (43) expr -> . expr * expr
    (44) expr -> . expr - expr
    (45) expr -> . expr + expr
    (46) expr -> . [ expr_list ]
    (47) expr -> . expr [ expr_list ]
    }               shift and go to state 55
    RETURN          shift and go to state 4
    CONTINUE        shift and go to state 6
    BREAK           shift and go to state 7
    FOR             shift and go to state 8
    WHILE           shift and go to state 10
    IF              shift and go to state 12
    PRINT           shift and go to state 13
    {               shift and go to state 14
    (               shift and go to state 11
    EYE             shift and go to state 15
    ONES            shift and go to state 16
    ZEROS           shift and go to state 17
    ID              shift and go to state 9
    STRING          shift and go to state 18
    FLOAT           shift and go to state 19
    INT             shift and go to state 20
    -               shift and go to state 21
    [               shift and go to state 22

    stmt_list                      shift and go to state 56
    stmt                           shift and go to state 3
    expr                           shift and go to state 5

state 15

    (23) expr -> EYE . ( expr_list )
    (               shift and go to state 57


state 16

    (24) expr -> ONES . ( expr_list )
    (               shift and go to state 58


state 17

    (25) expr -> ZEROS . ( expr_list )
    (               shift and go to state 59


state 18

    (27) expr -> STRING .
    DIVASSIGN       reduce using rule 27 (expr -> STRING .)
    MULASSIGN       reduce using rule 27 (expr -> STRING .)
    SUBASSIGN       reduce using rule 27 (expr -> STRING .)
    ADDASSIGN       reduce using rule 27 (expr -> STRING .)
    =               reduce using rule 27 (expr -> STRING .)
    ;               reduce using rule 27 (expr -> STRING .)
    '               reduce using rule 27 (expr -> STRING .)
    GEQ             reduce using rule 27 (expr -> STRING .)
    LEQ             reduce using rule 27 (expr -> STRING .)
    >               reduce using rule 27 (expr -> STRING .)
    <               reduce using rule 27 (expr -> STRING .)
    NEQ             reduce using rule 27 (expr -> STRING .)
    EQ              reduce using rule 27 (expr -> STRING .)
    DOTDIV          reduce using rule 27 (expr -> STRING .)
    DOTMUL          reduce using rule 27 (expr -> STRING .)
    DOTSUB          reduce using rule 27 (expr -> STRING .)
    DOTADD          reduce using rule 27 (expr -> STRING .)
    /               reduce using rule 27 (expr -> STRING .)
    *               reduce using rule 27 (expr -> STRING .)
    -               reduce using rule 27 (expr -> STRING .)
    +               reduce using rule 27 (expr -> STRING .)
    [               reduce using rule 27 (expr -> STRING .)
    )               reduce using rule 27 (expr -> STRING .)
    ,               reduce using rule 27 (expr -> STRING .)
    ]               reduce using rule 27 (expr -> STRING .)
    :               reduce using rule 27 (expr -> STRING .)
    RETURN          reduce using rule 27 (expr -> STRING .)
    CONTINUE        reduce using rule 27 (expr -> STRING .)
    BREAK           reduce using rule 27 (expr -> STRING .)
    FOR             reduce using rule 27 (expr -> STRING .)
    WHILE           reduce using rule 27 (expr -> STRING .)
    IF              reduce using rule 27 (expr -> STRING .)
    PRINT           reduce using rule 27 (expr -> STRING .)
    {               reduce using rule 27 (expr -> STRING .)
    (               reduce using rule 27 (expr -> STRING .)
    EYE             reduce using rule 27 (expr -> STRING .)
    ONES            reduce using rule 27 (expr -> STRING .)
    ZEROS           reduce using rule 27 (expr -> STRING .)
    ID              reduce using rule 27 (expr -> STRING .)
    STRING          reduce using rule 27 (expr -> STRING .)
    FLOAT           reduce using rule 27 (expr -> STRING .)
    INT             reduce using rule 27 (expr -> STRING .)


state 19

    (28) expr -> FLOAT .
    DIVASSIGN       reduce using rule 28 (expr -> FLOAT .)
    MULASSIGN       reduce using rule 28 (expr -> FLOAT .)
    SUBASSIGN       reduce using rule 28 (expr -> FLOAT .)
    ADDASSIGN       reduce using rule 28 (expr -> FLOAT .)
    =               reduce using rule 28 (expr -> FLOAT .)
    ;               reduce using rule 28 (expr -> FLOAT .)
    '               reduce using rule 28 (expr -> FLOAT .)
    GEQ             reduce using rule 28 (expr -> FLOAT .)
    LEQ             reduce using rule 28 (expr -> FLOAT .)
    >               reduce using rule 28 (expr -> FLOAT .)
    <               reduce using rule 28 (expr -> FLOAT .)
    NEQ             reduce using rule 28 (expr -> FLOAT .)
    EQ              reduce using rule 28 (expr -> FLOAT .)
    DOTDIV          reduce using rule 28 (expr -> FLOAT .)
    DOTMUL          reduce using rule 28 (expr -> FLOAT .)
    DOTSUB          reduce using rule 28 (expr -> FLOAT .)
    DOTADD          reduce using rule 28 (expr -> FLOAT .)
    /               reduce using rule 28 (expr -> FLOAT .)
    *               reduce using rule 28 (expr -> FLOAT .)
    -               reduce using rule 28 (expr -> FLOAT .)
    +               reduce using rule 28 (expr -> FLOAT .)
    [               reduce using rule 28 (expr -> FLOAT .)
    )               reduce using rule 28 (expr -> FLOAT .)
    ,               reduce using rule 28 (expr -> FLOAT .)
    ]               reduce using rule 28 (expr -> FLOAT .)
    :               reduce using rule 28 (expr -> FLOAT .)
    RETURN          reduce using rule 28 (expr -> FLOAT .)
    CONTINUE        reduce using rule 28 (expr -> FLOAT .)
    BREAK           reduce using rule 28 (expr -> FLOAT .)
    FOR             reduce using rule 28 (expr -> FLOAT .)
    WHILE           reduce using rule 28 (expr -> FLOAT .)
    IF              reduce using rule 28 (expr -> FLOAT .)
    PRINT           reduce using rule 28 (expr -> FLOAT .)
    {               reduce using rule 28 (expr -> FLOAT .)
    (               reduce using rule 28 (expr -> FLOAT .)
    EYE             reduce using rule 28 (expr -> FLOAT .)
    ONES            reduce using rule 28 (expr -> FLOAT .)
    ZEROS           reduce using rule 28 (expr -> FLOAT .)
    ID              reduce using rule 28 (expr -> FLOAT .)
    STRING          reduce using rule 28 (expr -> FLOAT .)
    FLOAT           reduce using rule 28 (expr -> FLOAT .)
    INT             reduce using rule 28 (expr -> FLOAT .)


state 20

    (29) expr -> INT .
    DIVASSIGN       reduce using rule 29 (expr -> INT .)
    MULASSIGN       reduce using rule 29 (expr -> INT .)
    SUBASSIGN       reduce using rule 29 (expr -> INT .)
    ADDASSIGN       reduce using rule 29 (expr -> INT .)
    =               reduce using rule 29 (expr -> INT .)
    ;               reduce using rule 29 (expr -> INT .)
    '               reduce using rule 29 (expr -> INT .)
    GEQ             reduce using rule 29 (expr -> INT .)
    LEQ             reduce using rule 29 (expr -> INT .)
    >               reduce using rule 29 (expr -> INT .)
    <               reduce using rule 29 (expr -> INT .)
    NEQ             reduce using rule 29 (expr -> INT .)
    EQ              reduce using rule 29 (expr -> INT .)
    DOTDIV          reduce using rule 29 (expr -> INT .)
    DOTMUL          reduce using rule 29 (expr -> INT .)
    DOTSUB          reduce using rule 29 (expr -> INT .)
    DOTADD          reduce using rule 29 (expr -> INT .)
    /               reduce using rule 29 (expr -> INT .)
    *               reduce using rule 29 (expr -> INT .)
    -               reduce using rule 29 (expr -> INT .)
    +               reduce using rule 29 (expr -> INT .)
    [               reduce using rule 29 (expr -> INT .)
    )               reduce using rule 29 (expr -> INT .)
    ,               reduce using rule 29 (expr -> INT .)
    ]               reduce using rule 29 (expr -> INT .)
    :               reduce using rule 29 (expr -> INT .)
    RETURN          reduce using rule 29 (expr -> INT .)
    CONTINUE        reduce using rule 29 (expr -> INT .)
    BREAK           reduce using rule 29 (expr -> INT .)
    FOR             reduce using rule 29 (expr -> INT .)
    WHILE           reduce using rule 29 (expr -> INT .)
    IF              reduce using rule 29 (expr -> INT .)
    PRINT           reduce using rule 29 (expr -> INT .)
    {               reduce using rule 29 (expr -> INT .)
    (               reduce using rule 29 (expr -> INT .)
    EYE             reduce using rule 29 (expr -> INT .)
    ONES            reduce using rule 29 (expr -> INT .)
    ZEROS           reduce using rule 29 (expr -> INT .)
    ID              reduce using rule 29 (expr -> INT .)
    STRING          reduce using rule 29 (expr -> INT .)
    FLOAT           reduce using rule 29 (expr -> INT .)
    INT             reduce using rule 29 (expr -> INT .)


state 21

    (31) expr -> - . expr
    (22) expr -> . ( expr )
    (23) expr -> . EYE ( expr_list )
    (24) expr -> . ONES ( expr_list )
    (25) expr -> . ZEROS ( expr_list )
    (26) expr -> . ID
    (27) expr -> . STRING
    (28) expr -> . FLOAT
    (29) expr -> . INT
    (30) expr -> . expr '
    (31) expr -> . - expr
    (32) expr -> . expr GEQ expr
    (33) expr -> . expr LEQ expr
    (34) expr -> . expr > expr
    (35) expr -> . expr < expr
    (36) expr -> . expr NEQ expr
    (37) expr -> . expr EQ expr
    (38) expr -> . expr DOTDIV expr
    (39) expr -> . expr DOTMUL expr
    (40) expr -> . expr DOTSUB expr
    (41) expr -> . expr DOTADD expr
    (42) expr -> . expr / expr
    (43) expr -> . expr * expr
    (44) expr -> . expr - expr
    (45) expr -> . expr + expr
    (46) expr -> . [ expr_list ]
    (47) expr -> . expr [ expr_list ]
    (               shift and go to state 11
    EYE             shift and go to state 15
    ONES            shift and go to state 16
    ZEROS           shift and go to state 17
    ID              shift and go to state 9
    STRING          shift and go to state 18
    FLOAT           shift and go to state 19
    INT             shift and go to state 20
    -               shift and go to state 21
    [               shift and go to state 22

    expr                           shift and go to state 60

state 22

    (46) expr -> [ . expr_list ]
    (20) expr_list -> . expr
    (21) expr_list -> . expr , expr_list
    (22) expr -> . ( expr )
    (23) expr -> . EYE ( expr_list )
    (24) expr -> . ONES ( expr_list )
    (25) expr -> . ZEROS ( expr_list )
    (26) expr -> . ID
    (27) expr -> . STRING
    (28) expr -> . FLOAT
    (29) expr -> . INT
    (30) expr -> . expr '
    (31) expr -> . - expr
    (32) expr -> . expr GEQ expr
    (33) expr -> . expr LEQ expr
    (34) expr -> . expr > expr
    (35) expr -> . expr < expr
    (36) expr -> . expr NEQ expr
    (37) expr -> . expr EQ expr
    (38) expr -> . expr DOTDIV expr
    (39) expr -> . expr DOTMUL expr
    (40) expr -> . expr DOTSUB expr
    (41) expr -> . expr DOTADD expr
    (42) expr -> . expr / expr
    (43) expr -> . expr * expr
    (44) expr -> . expr - expr
    (45) expr -> . expr + expr
    (46) expr -> . [ expr_list ]
    (47) expr -> . expr [ expr_list ]
    (               shift and go to state 11
    EYE             shift and go to state 15
    ONES            shift and go to state 16
    ZEROS           shift and go to state 17
    ID              shift and go to state 9
    STRING          shift and go to state 18
    FLOAT           shift and go to state 19
    INT             shift and go to state 20
    -               shift and go to state 21
    [               shift and go to state 22

    expr_list                      shift and go to state 61
    expr                           shift and go to state 54

state 23

    (3) stmt_list -> stmt_list stmt .
    RETURN          reduce using rule 3 (stmt_list -> stmt_list stmt .)
    CONTINUE        reduce using rule 3 (stmt_list -> stmt_list stmt .)
    BREAK           reduce using rule 3 (stmt_list -> stmt_list stmt .)
    FOR             reduce using rule 3 (stmt_list -> stmt_list stmt .)
    WHILE           reduce using rule 3 (stmt_list -> stmt_list stmt .)
    IF              reduce using rule 3 (stmt_list -> stmt_list stmt .)
    PRINT           reduce using rule 3 (stmt_list -> stmt_list stmt .)
    {               reduce using rule 3 (stmt_list -> stmt_list stmt .)
    (               reduce using rule 3 (stmt_list -> stmt_list stmt .)
    EYE             reduce using rule 3 (stmt_list -> stmt_list stmt .)
    ONES            reduce using rule 3 (stmt_list -> stmt_list stmt .)
    ZEROS           reduce using rule 3 (stmt_list -> stmt_list stmt .)
    ID              reduce using rule 3 (stmt_list -> stmt_list stmt .)
    STRING          reduce using rule 3 (stmt_list -> stmt_list stmt .)
    FLOAT           reduce using rule 3 (stmt_list -> stmt_list stmt .)
    INT             reduce using rule 3 (stmt_list -> stmt_list stmt .)
    -               reduce using rule 3 (stmt_list -> stmt_list stmt .)
    [               reduce using rule 3 (stmt_list -> stmt_list stmt .)
    $end            reduce using rule 3 (stmt_list -> stmt_list stmt .)
    }               reduce using rule 3 (stmt_list -> stmt_list stmt .)


state 24

    (4) stmt -> RETURN expr . ;
    (30) expr -> expr . '
    (32) expr -> expr . GEQ expr
    (33) expr -> expr . LEQ expr
    (34) expr -> expr . > expr
    (35) expr -> expr . < expr
    (36) expr -> expr . NEQ expr
    (37) expr -> expr . EQ expr
    (38) expr -> expr . DOTDIV expr
    (39) expr -> expr . DOTMUL expr
    (40) expr -> expr . DOTSUB expr
    (41) expr -> expr . DOTADD expr
    (42) expr -> expr . / expr
    (43) expr -> expr . * expr
    (44) expr -> expr . - expr
    (45) expr -> expr . + expr
    (47) expr -> expr . [ expr_list ]
    ;               shift and go to state 62
    '               shift and go to state 31
    GEQ             shift and go to state 32
    LEQ             shift and go to state 33
    >               shift and go to state 34
    <               shift and go to state 35
    NEQ             shift and go to state 36
    EQ              shift and go to state 37
    DOTDIV          shift and go to state 38
    DOTMUL          shift and go to state 39
    DOTSUB          shift and go to state 40
    DOTADD          shift and go to state 41
    /               shift and go to state 42
    *               shift and go to state 43
    -               shift and go to state 44
    +               shift and go to state 45
    [               shift and go to state 46


state 25

    (12) stmt -> expr DIVASSIGN . expr ;
    (22) expr -> . ( expr )
    (23) expr -> . EYE ( expr_list )
    (24) expr -> . ONES ( expr_list )
    (25) expr -> . ZEROS ( expr_list )
    (26) expr -> . ID
    (27) expr -> . STRING
    (28) expr -> . FLOAT
    (29) expr -> . INT
    (30) expr -> . expr '
    (31) expr -> . - expr
    (32) expr -> . expr GEQ expr
    (33) expr -> . expr LEQ expr
    (34) expr -> . expr > expr
    (35) expr -> . expr < expr
    (36) expr -> . expr NEQ expr
    (37) expr -> . expr EQ expr
    (38) expr -> . expr DOTDIV expr
    (39) expr -> . expr DOTMUL expr
    (40) expr -> . expr DOTSUB expr
    (41) expr -> . expr DOTADD expr
    (42) expr -> . expr / expr
    (43) expr -> . expr * expr
    (44) expr -> . expr - expr
    (45) expr -> . expr + expr
    (46) expr -> . [ expr_list ]
    (47) expr -> . expr [ expr_list ]
    (               shift and go to state 11
    EYE             shift and go to state 15
    ONES            shift and go to state 16
    ZEROS           shift and go to state 17
    ID              shift and go to state 9
    STRING          shift and go to state 18
    FLOAT           shift and go to state 19
    INT             shift and go to state 20
    -               shift and go to state 21
    [               shift and go to state 22

    expr                           shift and go to state 63

state 26

    (17) stmt -> expr ; .
    RETURN          reduce using rule 17 (stmt -> expr ; .)
    CONTINUE        reduce using rule 17 (stmt -> expr ; .)
    BREAK           reduce using rule 17 (stmt -> expr ; .)
    FOR             reduce using rule 17 (stmt -> expr ; .)
    WHILE           reduce using rule 17 (stmt -> expr ; .)
    IF              reduce using rule 17 (stmt -> expr ; .)
    PRINT           reduce using rule 17 (stmt -> expr ; .)
    {               reduce using rule 17 (stmt -> expr ; .)
    (               reduce using rule 17 (stmt -> expr ; .)
    EYE             reduce using rule 17 (stmt -> expr ; .)
    ONES            reduce using rule 17 (stmt -> expr ; .)
    ZEROS           reduce using rule 17 (stmt -> expr ; .)
    ID              reduce using rule 17 (stmt -> expr ; .)
    STRING          reduce using rule 17 (stmt -> expr ; .)
    FLOAT           reduce using rule 17 (stmt -> expr ; .)
    INT             reduce using rule 17 (stmt -> expr ; .)
    -               reduce using rule 17 (stmt -> expr ; .)
    [               reduce using rule 17 (stmt -> expr ; .)
    $end            reduce using rule 17 (stmt -> expr ; .)
    }               reduce using rule 17 (stmt -> expr ; .)
    ELSE            reduce using rule 17 (stmt -> expr ; .)


state 27

    (13) stmt -> expr MULASSIGN . expr ;
    (22) expr -> . ( expr )
    (23) expr -> . EYE ( expr_list )
    (24) expr -> . ONES ( expr_list )
    (25) expr -> . ZEROS ( expr_list )
    (26) expr -> . ID
    (27) expr -> . STRING
    (28) expr -> . FLOAT
    (29) expr -> . INT
    (30) expr -> . expr '
    (31) expr -> . - expr
    (32) expr -> . expr GEQ expr
    (33) expr -> . expr LEQ expr
    (34) expr -> . expr > expr
    (35) expr -> . expr < expr
    (36) expr -> . expr NEQ expr
    (37) expr -> . expr EQ expr
    (38) expr -> . expr DOTDIV expr
    (39) expr -> . expr DOTMUL expr
    (40) expr -> . expr DOTSUB expr
    (41) expr -> . expr DOTADD expr
    (42) expr -> . expr / expr
    (43) expr -> . expr * expr
    (44) expr -> . expr - expr
    (45) expr -> . expr + expr
    (46) expr -> . [ expr_list ]
    (47) expr -> . expr [ expr_list ]
    (               shift and go to state 11
    EYE             shift and go to state 15
    ONES            shift and go to state 16
    ZEROS           shift and go to state 17
    ID              shift and go to state 9
    STRING          shift and go to state 18
    FLOAT           shift and go to state 19
    INT             shift and go to state 20
    -               shift and go to state 21
    [               shift and go to state 22

    expr                           shift and go to state 64

state 28

    (14) stmt -> expr SUBASSIGN . expr ;
    (22) expr -> . ( expr )
    (23) expr -> . EYE ( expr_list )
    (24) expr -> . ONES ( expr_list )
    (25) expr -> . ZEROS ( expr_list )
    (26) expr -> . ID
    (27) expr -> . STRING
    (28) expr -> . FLOAT
    (29) expr -> . INT
    (30) expr -> . expr '
    (31) expr -> . - expr
    (32) expr -> . expr GEQ expr
    (33) expr -> . expr LEQ expr
    (34) expr -> . expr > expr
    (35) expr -> . expr < expr
    (36) expr -> . expr NEQ expr
    (37) expr -> . expr EQ expr
    (38) expr -> . expr DOTDIV expr
    (39) expr -> . expr DOTMUL expr
    (40) expr -> . expr DOTSUB expr
    (41) expr -> . expr DOTADD expr
    (42) expr -> . expr / expr
    (43) expr -> . expr * expr
    (44) expr -> . expr - expr
    (45) expr -> . expr + expr
    (46) expr -> . [ expr_list ]
    (47) expr -> . expr [ expr_list ]
    (               shift and go to state 11
    EYE             shift and go to state 15
    ONES            shift and go to state 16
    ZEROS           shift and go to state 17
    ID              shift and go to state 9
    STRING          shift and go to state 18
    FLOAT           shift and go to state 19
    INT             shift and go to state 20
    -               shift and go to state 21
    [               shift and go to state 22

    expr                           shift and go to state 65

state 29

    (15) stmt -> expr ADDASSIGN . expr ;
    (22) expr -> . ( expr )
    (23) expr -> . EYE ( expr_list )
    (24) expr -> . ONES ( expr_list )
    (25) expr -> . ZEROS ( expr_list )
    (26) expr -> . ID
    (27) expr -> . STRING
    (28) expr -> . FLOAT
    (29) expr -> . INT
    (30) expr -> . expr '
    (31) expr -> . - expr
    (32) expr -> . expr GEQ expr
    (33) expr -> . expr LEQ expr
    (34) expr -> . expr > expr
    (35) expr -> . expr < expr
    (36) expr -> . expr NEQ expr
    (37) expr -> . expr EQ expr
    (38) expr -> . expr DOTDIV expr
    (39) expr -> . expr DOTMUL expr
    (40) expr -> . expr DOTSUB expr
    (41) expr -> . expr DOTADD expr
    (42) expr -> . expr / expr
    (43) expr -> . expr * expr
    (44) expr -> . expr - expr
    (45) expr -> . expr + expr
    (46) expr -> . [ expr_list ]
    (47) expr -> . expr [ expr_list ]
    (               shift and go to state 11
    EYE             shift and go to state 15
    ONES            shift and go to state 16
    ZEROS           shift and go to state 17
    ID              shift and go to state 9
    STRING          shift and go to state 18
    FLOAT           shift and go to state 19
    INT             shift and go to state 20
    -               shift and go to state 21
    [               shift and go to state 22

    expr                           shift and go to state 66

state 30

    (16) stmt -> expr = . expr ;
    (22) expr -> . ( expr )
    (23) expr -> . EYE ( expr_list )
    (24) expr -> . ONES ( expr_list )
    (25) expr -> . ZEROS ( expr_list )
    (26) expr -> . ID
    (27) expr -> . STRING
    (28) expr -> . FLOAT
    (29) expr -> . INT
    (30) expr -> . expr '
    (31) expr -> . - expr
    (32) expr -> . expr GEQ expr
    (33) expr -> . expr LEQ expr
    (34) expr -> . expr > expr
    (35) expr -> . expr < expr
    (36) expr -> . expr NEQ expr
    (37) expr -> . expr EQ expr
    (38) expr -> . expr DOTDIV expr
    (39) expr -> . expr DOTMUL expr
    (40) expr -> . expr DOTSUB expr
    (41) expr -> . expr DOTADD expr
    (42) expr -> . expr / expr
    (43) expr -> . expr * expr
    (44) expr -> . expr - expr
    (45) expr -> . expr + expr
    (46) expr -> . [ expr_list ]
    (47) expr -> . expr [ expr_list ]
    (               shift and go to state 11
    EYE             shift and go to state 15
    ONES            shift and go to state 16
    ZEROS           shift and go to state 17
    ID              shift and go to state 9
    STRING          shift and go to state 18
    FLOAT           shift and go to state 19
    INT             shift and go to state 20
    -               shift and go to state 21
    [               shift and go to state 22

    expr                           shift and go to state 67

state 31

    (30) expr -> expr ' .
    DIVASSIGN       reduce using rule 30 (expr -> expr ' .)
    MULASSIGN       reduce using rule 30 (expr -> expr ' .)
    SUBASSIGN       reduce using rule 30 (expr -> expr ' .)
    ADDASSIGN       reduce using rule 30 (expr -> expr ' .)
    =               reduce using rule 30 (expr -> expr ' .)
    ;               reduce using rule 30 (expr -> expr ' .)
    '               reduce using rule 30 (expr -> expr ' .)
    GEQ             reduce using rule 30 (expr -> expr ' .)
    LEQ             reduce using rule 30 (expr -> expr ' .)
    >               reduce using rule 30 (expr -> expr ' .)
    <               reduce using rule 30 (expr -> expr ' .)
    NEQ             reduce using rule 30 (expr -> expr ' .)
    EQ              reduce using rule 30 (expr -> expr ' .)
    DOTDIV          reduce using rule 30 (expr -> expr ' .)
    DOTMUL          reduce using rule 30 (expr -> expr ' .)
    DOTSUB          reduce using rule 30 (expr -> expr ' .)
    DOTADD          reduce using rule 30 (expr -> expr ' .)
    /               reduce using rule 30 (expr -> expr ' .)
    *               reduce using rule 30 (expr -> expr ' .)
    -               reduce using rule 30 (expr -> expr ' .)
    +               reduce using rule 30 (expr -> expr ' .)
    [               reduce using rule 30 (expr -> expr ' .)
    )               reduce using rule 30 (expr -> expr ' .)
    ,               reduce using rule 30 (expr -> expr ' .)
    ]               reduce using rule 30 (expr -> expr ' .)
    :               reduce using rule 30 (expr -> expr ' .)
    RETURN          reduce using rule 30 (expr -> expr ' .)
    CONTINUE        reduce using rule 30 (expr -> expr ' .)
    BREAK           reduce using rule 30 (expr -> expr ' .)
    FOR             reduce using rule 30 (expr -> expr ' .)
    WHILE           reduce using rule 30 (expr -> expr ' .)
    IF              reduce using rule 30 (expr -> expr ' .)
    PRINT           reduce using rule 30 (expr -> expr ' .)
    {               reduce using rule 30 (expr -> expr ' .)
    (               reduce using rule 30 (expr -> expr ' .)
    EYE             reduce using rule 30 (expr -> expr ' .)
    ONES            reduce using rule 30 (expr -> expr ' .)
    ZEROS           reduce using rule 30 (expr -> expr ' .)
    ID              reduce using rule 30 (expr -> expr ' .)
    STRING          reduce using rule 30 (expr -> expr ' .)
    FLOAT           reduce using rule 30 (expr -> expr ' .)
    INT             reduce using rule 30 (expr -> expr ' .)


state 32

    (32) expr -> expr GEQ . expr
    (22) expr -> . ( expr )
    (23) expr -> . EYE ( expr_list )
    (24) expr -> . ONES ( expr_list )
    (25) expr -> . ZEROS ( expr_list )
    (26) expr -> . ID
    (27) expr -> . STRING
    (28) expr -> . FLOAT
    (29) expr -> . INT
    (30) expr -> . expr '
    (31) expr -> . - expr
    (32) expr -> . expr GEQ expr
    (33) expr -> . expr LEQ expr
    (34) expr -> . expr > expr
    (35) expr -> . expr < expr
    (36) expr -> . expr NEQ expr
    (37) expr -> . expr EQ expr
    (38) expr -> . expr DOTDIV expr
    (39) expr -> . expr DOTMUL expr
    (40) expr -> . expr DOTSUB expr
    (41) expr -> . expr DOTADD expr
    (42) expr -> . expr / expr
    (43) expr -> . expr * expr
    (44) expr -> . expr - expr
    (45) expr -> . expr + expr
    (46) expr -> . [ expr_list ]
    (47) expr -> . expr [ expr_list ]
    (               shift and go to state 11
    EYE             shift and go to state 15
    ONES            shift and go to state 16
    ZEROS           shift and go to state 17
    ID              shift and go to state 9
    STRING          shift and go to state 18
    FLOAT           shift and go to state 19
    INT             shift and go to state 20
    -               shift and go to state 21
    [               shift and go to state 22

    expr                           shift and go to state 68

state 33

    (33) expr -> expr LEQ . expr
    (22) expr -> . ( expr )
    (23) expr -> . EYE ( expr_list )
    (24) expr -> . ONES ( expr_list )
    (25) expr -> . ZEROS ( expr_list )
    (26) expr -> . ID
    (27) expr -> . STRING
    (28) expr -> . FLOAT
    (29) expr -> . INT
    (30) expr -> . expr '
    (31) expr -> . - expr
    (32) expr -> . expr GEQ expr
    (33) expr -> . expr LEQ expr
    (34) expr -> . expr > expr
    (35) expr -> . expr < expr
    (36) expr -> . expr NEQ expr
    (37) expr -> . expr EQ expr
    (38) expr -> . expr DOTDIV expr
    (39) expr -> . expr DOTMUL expr
    (40) expr -> . expr DOTSUB expr
    (41) expr -> . expr DOTADD expr
    (42) expr -> . expr / expr
    (43) expr -> . expr * expr
    (44) expr -> . expr - expr
    (45) expr -> . expr + expr
    (46) expr -> . [ expr_list ]
    (47) expr -> . expr [ expr_list ]
    (               shift and go to state 11
    EYE             shift and go to state 15
    ONES            shift and go to state 16
    ZEROS           shift and go to state 17
    ID              shift and go to state 9
    STRING          shift and go to state 18
    FLOAT           shift and go to state 19
    INT             shift and go to state 20
    -               shift and go to state 21
    [               shift and go to state 22

    expr                           shift and go to state 69

state 34

    (34) expr -> expr > . expr
    (22) expr -> . ( expr )
    (23) expr -> . EYE ( expr_list )
    (24) expr -> . ONES ( expr_list )
    (25) expr -> . ZEROS ( expr_list )
    (26) expr -> . ID
    (27) expr -> . STRING
    (28) expr -> . FLOAT
    (29) expr -> . INT
    (30) expr -> . expr '
    (31) expr -> . - expr
    (32) expr -> . expr GEQ expr
    (33) expr -> . expr LEQ expr
    (34) expr -> . expr > expr
    (35) expr -> . expr < expr
    (36) expr -> . expr NEQ expr
    (37) expr -> . expr EQ expr
    (38) expr -> . expr DOTDIV expr
    (39) expr -> . expr DOTMUL expr
    (40) expr -> . expr DOTSUB expr
    (41) expr -> . expr DOTADD expr
    (42) expr -> . expr / expr
    (43) expr -> . expr * expr
    (44) expr -> . expr - expr
    (45) expr -> . expr + expr
    (46) expr -> . [ expr_list ]
    (47) expr -> . expr [ expr_list ]
    (               shift and go to state 11
    EYE             shift and go to state 15
    ONES            shift and go to state 16
    ZEROS           shift and go to state 17
    ID              shift and go to state 9
    STRING          shift and go to state 18
    FLOAT           shift and go to state 19
    INT             shift and go to state 20
    -               shift and go to state 21
    [               shift and go to state 22

    expr                           shift and go to state 70

state 35

    (35) expr -> expr < . expr
    (22) expr -> . ( expr )
    (23) expr -> . EYE ( expr_list )
    (24) expr -> . ONES ( expr_list )
    (25) expr -> . ZEROS ( expr_list )
    (26) expr -> . ID
    (27) expr -> . STRING
    (28) expr -> . FLOAT
    (29) expr -> . INT
    (30) expr -> . expr '
    (31) expr -> . - expr
    (32) expr -> . expr GEQ expr
    (33) expr -> . expr LEQ expr
    (34) expr -> . expr > expr
    (35) expr -> . expr < expr
    (36) expr -> . expr NEQ expr
    (37) expr -> . expr EQ expr
    (38) expr -> . expr DOTDIV expr
    (39) expr -> . expr DOTMUL expr
    (40) expr -> . expr DOTSUB expr
    (41) expr -> . expr DOTADD expr
    (42) expr -> . expr / expr
    (43) expr -> . expr * expr
    (44) expr -> . expr - expr
    (45) expr -> . expr + expr
    (46) expr -> . [ expr_list ]
    (47) expr -> . expr [ expr_list ]
    (               shift and go to state 11
    EYE             shift and go to state 15
    ONES            shift and go to state 16
    ZEROS           shift and go to state 17
    ID              shift and go to state 9
    STRING          shift and go to state 18
    FLOAT           shift and go to state 19
    INT             shift and go to state 20
    -               shift and go to state 21
    [               shift and go to state 22

    expr                           shift and go to state 71

state 36

    (36) expr -> expr NEQ . expr
    (22) expr -> . ( expr )
    (23) expr -> . EYE ( expr_list )
    (24) expr -> . ONES ( expr_list )
    (25) expr -> . ZEROS ( expr_list )
    (26) expr -> . ID
    (27) expr -> . STRING
    (28) expr -> . FLOAT
    (29) expr -> . INT
    (30) expr -> . expr '
    (31) expr -> . - expr
    (32) expr -> . expr GEQ expr
    (33) expr -> . expr LEQ expr
    (34) expr -> . expr > expr
    (35) expr -> . expr < expr
    (36) expr -> . expr NEQ expr
    (37) expr -> . expr EQ expr
    (38) expr -> . expr DOTDIV expr
    (39) expr -> . expr DOTMUL expr
    (40) expr -> . expr DOTSUB expr
    (41) expr -> . expr DOTADD expr
    (42) expr -> . expr / expr
    (43) expr -> . expr * expr
    (44) expr -> . expr - expr
    (45) expr -> . expr + expr
    (46) expr -> . [ expr_list ]
    (47) expr -> . expr [ expr_list ]
    (               shift and go to state 11
    EYE             shift and go to state 15
    ONES            shift and go to state 16
    ZEROS           shift and go to state 17
    ID              shift and go to state 9
    STRING          shift and go to state 18
    FLOAT           shift and go to state 19
    INT             shift and go to state 20
    -               shift and go to state 21
    [               shift and go to state 22

    expr                           shift and go to state 72

state 37

    (37) expr -> expr EQ . expr
    (22) expr -> . ( expr )
    (23) expr -> . EYE ( expr_list )
    (24) expr -> . ONES ( expr_list )
    (25) expr -> . ZEROS ( expr_list )
    (26) expr -> . ID
    (27) expr -> . STRING
    (28) expr -> . FLOAT
    (29) expr -> . INT
    (30) expr -> . expr '
    (31) expr -> . - expr
    (32) expr -> . expr GEQ expr
    (33) expr -> . expr LEQ expr
    (34) expr -> . expr > expr
    (35) expr -> . expr < expr
    (36) expr -> . expr NEQ expr
    (37) expr -> . expr EQ expr
    (38) expr -> . expr DOTDIV expr
    (39) expr -> . expr DOTMUL expr
    (40) expr -> . expr DOTSUB expr
    (41) expr -> . expr DOTADD expr
    (42) expr -> . expr / expr
    (43) expr -> . expr * expr
    (44) expr -> . expr - expr
    (45) expr -> . expr + expr
    (46) expr -> . [ expr_list ]
    (47) expr -> . expr [ expr_list ]
    (               shift and go to state 11
    EYE             shift and go to state 15
    ONES            shift and go to state 16
    ZEROS           shift and go to state 17
    ID              shift and go to state 9
    STRING          shift and go to state 18
    FLOAT           shift and go to state 19
    INT             shift and go to state 20
    -               shift and go to state 21
    [               shift and go to state 22

    expr                           shift and go to state 73

state 38

    (38) expr -> expr DOTDIV . expr
    (22) expr -> . ( expr )
    (23) expr -> . EYE ( expr_list )
    (24) expr -> . ONES ( expr_list )
    (25) expr -> . ZEROS ( expr_list )
    (26) expr -> . ID
    (27) expr -> . STRING
    (28) expr -> . FLOAT
    (29) expr -> . INT
    (30) expr -> . expr '
    (31) expr -> . - expr
    (32) expr -> . expr GEQ expr
    (33) expr -> . expr LEQ expr
    (34) expr -> . expr > expr
    (35) expr -> . expr < expr
    (36) expr -> . expr NEQ expr
    (37) expr -> . expr EQ expr
    (38) expr -> . expr DOTDIV expr
    (39) expr -> . expr DOTMUL expr
    (40) expr -> . expr DOTSUB expr
    (41) expr -> . expr DOTADD expr
    (42) expr -> . expr / expr
    (43) expr -> . expr * expr
    (44) expr -> . expr - expr
    (45) expr -> . expr + expr
    (46) expr -> . [ expr_list ]
    (47) expr -> . expr [ expr_list ]
    (               shift and go to state 11
    EYE             shift and go to state 15
    ONES            shift and go to state 16
    ZEROS           shift and go to state 17
    ID              shift and go to state 9
    STRING          shift and go to state 18
    FLOAT           shift and go to state 19
    INT             shift and go to state 20
    -               shift and go to state 21
    [               shift and go to state 22

    expr                           shift and go to state 74

state 39

    (39) expr -> expr DOTMUL . expr
    (22) expr -> . ( expr )
    (23) expr -> . EYE ( expr_list )
    (24) expr -> . ONES ( expr_list )
    (25) expr -> . ZEROS ( expr_list )
    (26) expr -> . ID
    (27) expr -> . STRING
    (28) expr -> . FLOAT
    (29) expr -> . INT
    (30) expr -> . expr '
    (31) expr -> . - expr
    (32) expr -> . expr GEQ expr
    (33) expr -> . expr LEQ expr
    (34) expr -> . expr > expr
    (35) expr -> . expr < expr
    (36) expr -> . expr NEQ expr
    (37) expr -> . expr EQ expr
    (38) expr -> . expr DOTDIV expr
    (39) expr -> . expr DOTMUL expr
    (40) expr -> . expr DOTSUB expr
    (41) expr -> . expr DOTADD expr
    (42) expr -> . expr / expr
    (43) expr -> . expr * expr
    (44) expr -> . expr - expr
    (45) expr -> . expr + expr
    (46) expr -> . [ expr_list ]
    (47) expr -> . expr [ expr_list ]
    (               shift and go to state 11
    EYE             shift and go to state 15
    ONES            shift and go to state 16
    ZEROS           shift and go to state 17
    ID              shift and go to state 9
    STRING          shift and go to state 18
    FLOAT           shift and go to state 19
    INT             shift and go to state 20
    -               shift and go to state 21
    [               shift and go to state 22

    expr                           shift and go to state 75

state 40

    (40) expr -> expr DOTSUB . expr
    (22) expr -> . ( expr )
    (23) expr -> . EYE ( expr_list )
    (24) expr -> . ONES ( expr_list )
    (25) expr -> . ZEROS ( expr_list )
    (26) expr -> . ID
    (27) expr -> . STRING
    (28) expr -> . FLOAT
    (29) expr -> . INT
    (30) expr -> . expr '
    (31) expr -> . - expr
    (32) expr -> . expr GEQ expr
    (33) expr -> . expr LEQ expr
    (34) expr -> . expr > expr
    (35) expr -> . expr < expr
    (36) expr -> . expr NEQ expr
    (37) expr -> . expr EQ expr
    (38) expr -> . expr DOTDIV expr
    (39) expr -> . expr DOTMUL expr
    (40) expr -> . expr DOTSUB expr
    (41) expr -> . expr DOTADD expr
    (42) expr -> . expr / expr
    (43) expr -> . expr * expr
    (44) expr -> . expr - expr
    (45) expr -> . expr + expr
    (46) expr -> . [ expr_list ]
    (47) expr -> . expr [ expr_list ]
    (               shift and go to state 11
    EYE             shift and go to state 15
    ONES            shift and go to state 16
    ZEROS           shift and go to state 17
    ID              shift and go to state 9
    STRING          shift and go to state 18
    FLOAT           shift and go to state 19
    INT             shift and go to state 20
    -               shift and go to state 21
    [               shift and go to state 22

    expr                           shift and go to state 76

state 41

    (41) expr -> expr DOTADD . expr
    (22) expr -> . ( expr )
    (23) expr -> . EYE ( expr_list )
    (24) expr -> . ONES ( expr_list )
    (25) expr -> . ZEROS ( expr_list )
    (26) expr -> . ID
    (27) expr -> . STRING
    (28) expr -> . FLOAT
    (29) expr -> . INT
    (30) expr -> . expr '
    (31) expr -> . - expr
    (32) expr -> . expr GEQ expr
    (33) expr -> . expr LEQ expr
    (34) expr -> . expr > expr
    (35) expr -> . expr < expr
    (36) expr -> . expr NEQ expr
    (37) expr -> . expr EQ expr
    (38) expr -> . expr DOTDIV expr
    (39) expr -> . expr DOTMUL expr
    (40) expr -> . expr DOTSUB expr
    (41) expr -> . expr DOTADD expr
    (42) expr -> . expr / expr
    (43) expr -> . expr * expr
    (44) expr -> . expr - expr
    (45) expr -> . expr + expr
    (46) expr -> . [ expr_list ]
    (47) expr -> . expr [ expr_list ]
    (               shift and go to state 11
    EYE             shift and go to state 15
    ONES            shift and go to state 16
    ZEROS           shift and go to state 17
    ID              shift and go to state 9
    STRING          shift and go to state 18
    FLOAT           shift and go to state 19
    INT             shift and go to state 20
    -               shift and go to state 21
    [               shift and go to state 22

    expr                           shift and go to state 77

state 42

    (42) expr -> expr / . expr
    (22) expr -> . ( expr )
    (23) expr -> . EYE ( expr_list )
    (24) expr -> . ONES ( expr_list )
    (25) expr -> . ZEROS ( expr_list )
    (26) expr -> . ID
    (27) expr -> . STRING
    (28) expr -> . FLOAT
    (29) expr -> . INT
    (30) expr -> . expr '
    (31) expr -> . - expr
    (32) expr -> . expr GEQ expr
    (33) expr -> . expr LEQ expr
    (34) expr -> . expr > expr
    (35) expr -> . expr < expr
    (36) expr -> . expr NEQ expr
    (37) expr -> . expr EQ expr
    (38) expr -> . expr DOTDIV expr
    (39) expr -> . expr DOTMUL expr
    (40) expr -> . expr DOTSUB expr
    (41) expr -> . expr DOTADD expr
    (42) expr -> . expr / expr
    (43) expr -> . expr * expr
    (44) expr -> . expr - expr
    (45) expr -> . expr + expr
    (46) expr -> . [ expr_list ]
    (47) expr -> . expr [ expr_list ]
    (               shift and go to state 11
    EYE             shift and go to state 15
    ONES            shift and go to state 16
    ZEROS           shift and go to state 17
    ID              shift and go to state 9
    STRING          shift and go to state 18
    FLOAT           shift and go to state 19
    INT             shift and go to state 20
    -               shift and go to state 21
    [               shift and go to state 22

    expr                           shift and go to state 78

state 43

    (43) expr -> expr * . expr
    (22) expr -> . ( expr )
    (23) expr -> . EYE ( expr_list )
    (24) expr -> . ONES ( expr_list )
    (25) expr -> . ZEROS ( expr_list )
    (26) expr -> . ID
    (27) expr -> . STRING
    (28) expr -> . FLOAT
    (29) expr -> . INT
    (30) expr -> . expr '
    (31) expr -> . - expr
    (32) expr -> . expr GEQ expr
    (33) expr -> . expr LEQ expr
    (34) expr -> . expr > expr
    (35) expr -> . expr < expr
    (36) expr -> . expr NEQ expr
    (37) expr -> . expr EQ expr
    (38) expr -> . expr DOTDIV expr
    (39) expr -> . expr DOTMUL expr
    (40) expr -> . expr DOTSUB expr
    (41) expr -> . expr DOTADD expr
    (42) expr -> . expr / expr
    (43) expr -> . expr * expr
    (44) expr -> . expr - expr
    (45) expr -> . expr + expr
    (46) expr -> . [ expr_list ]
    (47) expr -> . expr [ expr_list ]
    (               shift and go to state 11
    EYE             shift and go to state 15
    ONES            shift and go to state 16
    ZEROS           shift and go to state 17
    ID              shift and go to state 9
    STRING          shift and go to state 18
    FLOAT           shift and go to state 19
    INT             shift and go to state 20
    -               shift and go to state 21
    [               shift and go to state 22

    expr                           shift and go to state 79

state 44

    (44) expr -> expr - . expr
    (22) expr -> . ( expr )
    (23) expr -> . EYE ( expr_list )
    (24) expr -> . ONES ( expr_list )
    (25) expr -> . ZEROS ( expr_list )
    (26) expr -> . ID
    (27) expr -> . STRING
    (28) expr -> . FLOAT
    (29) expr -> . INT
    (30) expr -> . expr '
    (31) expr -> . - expr
    (32) expr -> . expr GEQ expr
    (33) expr -> . expr LEQ expr
    (34) expr -> . expr > expr
    (35) expr -> . expr < expr
    (36) expr -> . expr NEQ expr
    (37) expr -> . expr EQ expr
    (38) expr -> . expr DOTDIV expr
    (39) expr -> . expr DOTMUL expr
    (40) expr -> . expr DOTSUB expr
    (41) expr -> . expr DOTADD expr
    (42) expr -> . expr / expr
    (43) expr -> . expr * expr
    (44) expr -> . expr - expr
    (45) expr -> . expr + expr
    (46) expr -> . [ expr_list ]
    (47) expr -> . expr [ expr_list ]
    (               shift and go to state 11
    EYE             shift and go to state 15
    ONES            shift and go to state 16
    ZEROS           shift and go to state 17
    ID              shift and go to state 9
    STRING          shift and go to state 18
    FLOAT           shift and go to state 19
    INT             shift and go to state 20
    -               shift and go to state 21
    [               shift and go to state 22

    expr                           shift and go to state 80

state 45

    (45) expr -> expr + . expr
    (22) expr -> . ( expr )
    (23) expr -> . EYE ( expr_list )
    (24) expr -> . ONES ( expr_list )
    (25) expr -> . ZEROS ( expr_list )
    (26) expr -> . ID
    (27) expr -> . STRING
    (28) expr -> . FLOAT
    (29) expr -> . INT
    (30) expr -> . expr '
    (31) expr -> . - expr
    (32) expr -> . expr GEQ expr
    (33) expr -> . expr LEQ expr
    (34) expr -> . expr > expr
    (35) expr -> . expr < expr
    (36) expr -> . expr NEQ expr
    (37) expr -> . expr EQ expr
    (38) expr -> . expr DOTDIV expr
    (39) expr -> . expr DOTMUL expr
    (40) expr -> . expr DOTSUB expr
    (41) expr -> . expr DOTADD expr
    (42) expr -> . expr / expr
    (43) expr -> . expr * expr
    (44) expr -> . expr - expr
    (45) expr -> . expr + expr
    (46) expr -> . [ expr_list ]
    (47) expr -> . expr [ expr_list ]
    (               shift and go to state 11
    EYE             shift and go to state 15
    ONES            shift and go to state 16
    ZEROS           shift and go to state 17
    ID              shift and go to state 9
    STRING          shift and go to state 18
    FLOAT           shift and go to state 19
    INT             shift and go to state 20
    -               shift and go to state 21
    [               shift and go to state 22

    expr                           shift and go to state 81

state 46

    (47) expr -> expr [ . expr_list ]
    (20) expr_list -> . expr
    (21) expr_list -> . expr , expr_list
    (22) expr -> . ( expr )
    (23) expr -> . EYE ( expr_list )
    (24) expr -> . ONES ( expr_list )
    (25) expr -> . ZEROS ( expr_list )
    (26) expr -> . ID
    (27) expr -> . STRING
    (28) expr -> . FLOAT
    (29) expr -> . INT
    (30) expr -> . expr '
    (31) expr -> . - expr
    (32) expr -> . expr GEQ expr
    (33) expr -> . expr LEQ expr
    (34) expr -> . expr > expr
    (35) expr -> . expr < expr
    (36) expr -> . expr NEQ expr
    (37) expr -> . expr EQ expr
    (38) expr -> . expr DOTDIV expr
    (39) expr -> . expr DOTMUL expr
    (40) expr -> . expr DOTSUB expr
    (41) expr -> . expr DOTADD expr
    (42) expr -> . expr / expr
    (43) expr -> . expr * expr
    (44) expr -> . expr - expr
    (45) expr -> . expr + expr
    (46) expr -> . [ expr_list ]
    (47) expr -> . expr [ expr_list ]
    (               shift and go to state 11
    EYE             shift and go to state 15
    ONES            shift and go to state 16
    ZEROS           shift and go to state 17
    ID              shift and go to state 9
    STRING          shift and go to state 18
    FLOAT           shift and go to state 19
    INT             shift and go to state 20
    -               shift and go to state 21
    [               shift and go to state 22

    expr                           shift and go to state 54
    expr_list                      shift and go to state 82

state 47

    (5) stmt -> CONTINUE ; .
    RETURN          reduce using rule 5 (stmt -> CONTINUE ; .)
    CONTINUE        reduce using rule 5 (stmt -> CONTINUE ; .)
    BREAK           reduce using rule 5 (stmt -> CONTINUE ; .)
    FOR             reduce using rule 5 (stmt -> CONTINUE ; .)
    WHILE           reduce using rule 5 (stmt -> CONTINUE ; .)
    IF              reduce using rule 5 (stmt -> CONTINUE ; .)
    PRINT           reduce using rule 5 (stmt -> CONTINUE ; .)
    {               reduce using rule 5 (stmt -> CONTINUE ; .)
    (               reduce using rule 5 (stmt -> CONTINUE ; .)
    EYE             reduce using rule 5 (stmt -> CONTINUE ; .)
    ONES            reduce using rule 5 (stmt -> CONTINUE ; .)
    ZEROS           reduce using rule 5 (stmt -> CONTINUE ; .)
    ID              reduce using rule 5 (stmt -> CONTINUE ; .)
    STRING          reduce using rule 5 (stmt -> CONTINUE ; .)
    FLOAT           reduce using rule 5 (stmt -> CONTINUE ; .)
    INT             reduce using rule 5 (stmt -> CONTINUE ; .)
    -               reduce using rule 5 (stmt -> CONTINUE ; .)
    [               reduce using rule 5 (stmt -> CONTINUE ; .)
    $end            reduce using rule 5 (stmt -> CONTINUE ; .)
    }               reduce using rule 5 (stmt -> CONTINUE ; .)
    ELSE            reduce using rule 5 (stmt -> CONTINUE ; .)


state 48

    (6) stmt -> BREAK ; .
    RETURN          reduce using rule 6 (stmt -> BREAK ; .)
    CONTINUE        reduce using rule 6 (stmt -> BREAK ; .)
    BREAK           reduce using rule 6 (stmt -> BREAK ; .)
    FOR             reduce using rule 6 (stmt -> BREAK ; .)
    WHILE           reduce using rule 6 (stmt -> BREAK ; .)
    IF              reduce using rule 6 (stmt -> BREAK ; .)
    PRINT           reduce using rule 6 (stmt -> BREAK ; .)
    {               reduce using rule 6 (stmt -> BREAK ; .)
    (               reduce using rule 6 (stmt -> BREAK ; .)
    EYE             reduce using rule 6 (stmt -> BREAK ; .)
    ONES            reduce using rule 6 (stmt -> BREAK ; .)
    ZEROS           reduce using rule 6 (stmt -> BREAK ; .)
    ID              reduce using rule 6 (stmt -> BREAK ; .)
    STRING          reduce using rule 6 (stmt -> BREAK ; .)
    FLOAT           reduce using rule 6 (stmt -> BREAK ; .)
    INT             reduce using rule 6 (stmt -> BREAK ; .)
    -               reduce using rule 6 (stmt -> BREAK ; .)
    [               reduce using rule 6 (stmt -> BREAK ; .)
    $end            reduce using rule 6 (stmt -> BREAK ; .)
    }               reduce using rule 6 (stmt -> BREAK ; .)
    ELSE            reduce using rule 6 (stmt -> BREAK ; .)


state 49

    (7) stmt -> FOR ID . = expr : expr stmt
    =               shift and go to state 83


state 50

    (8) stmt -> WHILE ( . expr ) stmt
    (22) expr -> . ( expr )
    (23) expr -> . EYE ( expr_list )
    (24) expr -> . ONES ( expr_list )
    (25) expr -> . ZEROS ( expr_list )
    (26) expr -> . ID
    (27) expr -> . STRING
    (28) expr -> . FLOAT
    (29) expr -> . INT
    (30) expr -> . expr '
    (31) expr -> . - expr
    (32) expr -> . expr GEQ expr
    (33) expr -> . expr LEQ expr
    (34) expr -> . expr > expr
    (35) expr -> . expr < expr
    (36) expr -> . expr NEQ expr
    (37) expr -> . expr EQ expr
    (38) expr -> . expr DOTDIV expr
    (39) expr -> . expr DOTMUL expr
    (40) expr -> . expr DOTSUB expr
    (41) expr -> . expr DOTADD expr
    (42) expr -> . expr / expr
    (43) expr -> . expr * expr
    (44) expr -> . expr - expr
    (45) expr -> . expr + expr
    (46) expr -> . [ expr_list ]
    (47) expr -> . expr [ expr_list ]
    (               shift and go to state 11
    EYE             shift and go to state 15
    ONES            shift and go to state 16
    ZEROS           shift and go to state 17
    ID              shift and go to state 9
    STRING          shift and go to state 18
    FLOAT           shift and go to state 19
    INT             shift and go to state 20
    -               shift and go to state 21
    [               shift and go to state 22

    expr                           shift and go to state 84

state 51

    (22) expr -> ( expr . )
    (30) expr -> expr . '
    (32) expr -> expr . GEQ expr
    (33) expr -> expr . LEQ expr
    (34) expr -> expr . > expr
    (35) expr -> expr . < expr
    (36) expr -> expr . NEQ expr
    (37) expr -> expr . EQ expr
    (38) expr -> expr . DOTDIV expr
    (39) expr -> expr . DOTMUL expr
    (40) expr -> expr . DOTSUB expr
    (41) expr -> expr . DOTADD expr
    (42) expr -> expr . / expr
    (43) expr -> expr . * expr
    (44) expr -> expr . - expr
    (45) expr -> expr . + expr
    (47) expr -> expr . [ expr_list ]
    )               shift and go to state 85
    '               shift and go to state 31
    GEQ             shift and go to state 32
    LEQ             shift and go to state 33
    >               shift and go to state 34
    <               shift and go to state 35
    NEQ             shift and go to state 36
    EQ              shift and go to state 37
    DOTDIV          shift and go to state 38
    DOTMUL          shift and go to state 39
    DOTSUB          shift and go to state 40
    DOTADD          shift and go to state 41
    /               shift and go to state 42
    *               shift and go to state 43
    -               shift and go to state 44
    +               shift and go to state 45
    [               shift and go to state 46


state 52

    (9) stmt -> IF ( . expr ) stmt
    (10) stmt -> IF ( . expr ) stmt ELSE stmt
    (22) expr -> . ( expr )
    (23) expr -> . EYE ( expr_list )
    (24) expr -> . ONES ( expr_list )
    (25) expr -> . ZEROS ( expr_list )
    (26) expr -> . ID
    (27) expr -> . STRING
    (28) expr -> . FLOAT
    (29) expr -> . INT
    (30) expr -> . expr '
    (31) expr -> . - expr
    (32) expr -> . expr GEQ expr
    (33) expr -> . expr LEQ expr
    (34) expr -> . expr > expr
    (35) expr -> . expr < expr
    (36) expr -> . expr NEQ expr
    (37) expr -> . expr EQ expr
    (38) expr -> . expr DOTDIV expr
    (39) expr -> . expr DOTMUL expr
    (40) expr -> . expr DOTSUB expr
    (41) expr -> . expr DOTADD expr
    (42) expr -> . expr / expr
    (43) expr -> . expr * expr
    (44) expr -> . expr - expr
    (45) expr -> . expr + expr
    (46) expr -> . [ expr_list ]
    (47) expr -> . expr [ expr_list ]
    (               shift and go to state 11
    EYE             shift and go to state 15
    ONES            shift and go to state 16
    ZEROS           shift and go to state 17
    ID              shift and go to state 9
    STRING          shift and go to state 18
    FLOAT           shift and go to state 19
    INT             shift and go to state 20
    -               shift and go to state 21
    [               shift and go to state 22

    expr                           shift and go to state 86

state 53

    (11) stmt -> PRINT expr_list . ;
    ;               shift and go to state 87


state 54

    (20) expr_list -> expr .
    (21) expr_list -> expr . , expr_list
    (30) expr -> expr . '
    (32) expr -> expr . GEQ expr
    (33) expr -> expr . LEQ expr
    (34) expr -> expr . > expr
    (35) expr -> expr . < expr
    (36) expr -> expr . NEQ expr
    (37) expr -> expr . EQ expr
    (38) expr -> expr . DOTDIV expr
    (39) expr -> expr . DOTMUL expr
    (40) expr -> expr . DOTSUB expr
    (41) expr -> expr . DOTADD expr
    (42) expr -> expr . / expr
    (43) expr -> expr . * expr
    (44) expr -> expr . - expr
    (45) expr -> expr . + expr
    (47) expr -> expr . [ expr_list ]
    ;               reduce using rule 20 (expr_list -> expr .)
    ]               reduce using rule 20 (expr_list -> expr .)
    )               reduce using rule 20 (expr_list -> expr .)
    ,               shift and go to state 88
    '               shift and go to state 31
    GEQ             shift and go to state 32
    LEQ             shift and go to state 33
    >               shift and go to state 34
    <               shift and go to state 35
    NEQ             shift and go to state 36
    EQ              shift and go to state 37
    DOTDIV          shift and go to state 38
    DOTMUL          shift and go to state 39
    DOTSUB          shift and go to state 40
    DOTADD          shift and go to state 41
    /               shift and go to state 42
    *               shift and go to state 43
    -               shift and go to state 44
    +               shift and go to state 45
    [               shift and go to state 46


state 55

    (18) stmt -> { } .
    RETURN          reduce using rule 18 (stmt -> { } .)
    CONTINUE        reduce using rule 18 (stmt -> { } .)
    BREAK           reduce using rule 18 (stmt -> { } .)
    FOR             reduce using rule 18 (stmt -> { } .)
    WHILE           reduce using rule 18 (stmt -> { } .)
    IF              reduce using rule 18 (stmt -> { } .)
    PRINT           reduce using rule 18 (stmt -> { } .)
    {               reduce using rule 18 (stmt -> { } .)
    (               reduce using rule 18 (stmt -> { } .)
    EYE             reduce using rule 18 (stmt -> { } .)
    ONES            reduce using rule 18 (stmt -> { } .)
    ZEROS           reduce using rule 18 (stmt -> { } .)
    ID              reduce using rule 18 (stmt -> { } .)
    STRING          reduce using rule 18 (stmt -> { } .)
    FLOAT           reduce using rule 18 (stmt -> { } .)
    INT             reduce using rule 18 (stmt -> { } .)
    -               reduce using rule 18 (stmt -> { } .)
    [               reduce using rule 18 (stmt -> { } .)
    $end            reduce using rule 18 (stmt -> { } .)
    }               reduce using rule 18 (stmt -> { } .)
    ELSE            reduce using rule 18 (stmt -> { } .)


state 56

    (19) stmt -> { stmt_list . }
    (3) stmt_list -> stmt_list . stmt
    (4) stmt -> . RETURN expr ;
    (5) stmt -> . CONTINUE ;
    (6) stmt -> . BREAK ;
    (7) stmt -> . FOR ID = expr : expr stmt
    (8) stmt -> . WHILE ( expr ) stmt
    (9) stmt -> . IF ( expr ) stmt
    (10) stmt -> . IF ( expr ) stmt ELSE stmt
    (11) stmt -> . PRINT expr_list ;
    (12) stmt -> . expr DIVASSIGN expr ;
    (13) stmt -> . expr MULASSIGN expr ;
    (14) stmt -> . expr SUBASSIGN expr ;
    (15) stmt -> . expr ADDASSIGN expr ;
    (16) stmt -> . expr = expr ;
    (17) stmt -> . expr ;
    (18) stmt -> . { }
    (19) stmt -> . { stmt_list }
    (22) expr -> . ( expr )
    (23) expr -> . EYE ( expr_list )
    (24) expr -> . ONES ( expr_list )
    (25) expr -> . ZEROS ( expr_list )
    (26) expr -> . ID
    (27) expr -> . STRING
    (28) expr -> . FLOAT
    (29) expr -> . INT
    (30) expr -> . expr '
    (31) expr -> . - expr
    (32) expr -> . expr GEQ expr
    (33) expr -> . expr LEQ expr
    (34) expr -> . expr > expr
    (35) expr -> . expr < expr
    (36) expr -> . expr NEQ expr
    (37) expr -> . expr EQ expr
    (38) expr -> . expr DOTDIV expr
    (39) expr -> . expr DOTMUL expr
    (40) expr -> . expr DOTSUB expr
    (41) expr -> . expr DOTADD expr
    (42) expr -> . expr / expr
    (43) expr -> . expr * expr
    (44) expr -> . expr - expr
    (45) expr -> . expr + expr
    (46) expr -> . [ expr_list ]
    (47) expr -> . expr [ expr_list ]
    }               shift and go to state 89
    RETURN          shift and go to state 4
    CONTINUE        shift and go to state 6
    BREAK           shift and go to state 7
    FOR             shift and go to state 8
    WHILE           shift and go to state 10
    IF              shift and go to state 12
    PRINT           shift and go to state 13
    {               shift and go to state 14
    (               shift and go to state 11
    EYE             shift and go to state 15
    ONES            shift and go to state 16
    ZEROS           shift and go to state 17
    ID              shift and go to state 9
    STRING          shift and go to state 18
    FLOAT           shift and go to state 19
    INT             shift and go to state 20
    -               shift and go to state 21
    [               shift and go to state 22

    stmt                           shift and go to state 23
    expr                           shift and go to state 5

state 57

    (23) expr -> EYE ( . expr_list )
    (20) expr_list -> . expr
    (21) expr_list -> . expr , expr_list
    (22) expr -> . ( expr )
    (23) expr -> . EYE ( expr_list )
    (24) expr -> . ONES ( expr_list )
    (25) expr -> . ZEROS ( expr_list )
    (26) expr -> . ID
    (27) expr -> . STRING
    (28) expr -> . FLOAT
    (29) expr -> . INT
    (30) expr -> . expr '
    (31) expr -> . - expr
    (32) expr -> . expr GEQ expr
    (33) expr -> . expr LEQ expr
    (34) expr -> . expr > expr
    (35) expr -> . expr < expr
    (36) expr -> . expr NEQ expr
    (37) expr -> . expr EQ expr
    (38) expr -> . expr DOTDIV expr
    (39) expr -> . expr DOTMUL expr
    (40) expr -> . expr DOTSUB expr
    (41) expr -> . expr DOTADD expr
    (42) expr -> . expr / expr
    (43) expr -> . expr * expr
    (44) expr -> . expr - expr
    (45) expr -> . expr + expr
    (46) expr -> . [ expr_list ]
    (47) expr -> . expr [ expr_list ]
    (               shift and go to state 11
    EYE             shift and go to state 15
    ONES            shift and go to state 16
    ZEROS           shift and go to state 17
    ID              shift and go to state 9
    STRING          shift and go to state 18
    FLOAT           shift and go to state 19
    INT             shift and go to state 20
    -               shift and go to state 21
    [               shift and go to state 22

    expr_list                      shift and go to state 90
    expr                           shift and go to state 54

state 58

    (24) expr -> ONES ( . expr_list )
    (20) expr_list -> . expr
    (21) expr_list -> . expr , expr_list
    (22) expr -> . ( expr )
    (23) expr -> . EYE ( expr_list )
    (24) expr -> . ONES ( expr_list )
    (25) expr -> . ZEROS ( expr_list )
    (26) expr -> . ID
    (27) expr -> . STRING
    (28) expr -> . FLOAT
    (29) expr -> . INT
    (30) expr -> . expr '
    (31) expr -> . - expr
    (32) expr -> . expr GEQ expr
    (33) expr -> . expr LEQ expr
    (34) expr -> . expr > expr
    (35) expr -> . expr < expr
    (36) expr -> . expr NEQ expr
    (37) expr -> . expr EQ expr
    (38) expr -> . expr DOTDIV expr
    (39) expr -> . expr DOTMUL expr
    (40) expr -> . expr DOTSUB expr
    (41) expr -> . expr DOTADD expr
    (42) expr -> . expr / expr
    (43) expr -> . expr * expr
    (44) expr -> . expr - expr
    (45) expr -> . expr + expr
    (46) expr -> . [ expr_list ]
    (47) expr -> . expr [ expr_list ]
    (               shift and go to state 11
    EYE             shift and go to state 15
    ONES            shift and go to state 16
    ZEROS           shift and go to state 17
    ID              shift and go to state 9
    STRING          shift and go to state 18
    FLOAT           shift and go to state 19
    INT             shift and go to state 20
    -               shift and go to state 21
    [               shift and go to state 22

    expr_list                      shift and go to state 91
    expr                           shift and go to state 54

state 59

    (25) expr -> ZEROS ( . expr_list )
    (20) expr_list -> . expr
    (21) expr_list -> . expr , expr_list
    (22) expr -> . ( expr )
    (23) expr -> . EYE ( expr_list )
    (24) expr -> . ONES ( expr_list )
    (25) expr -> . ZEROS ( expr_list )
    (26) expr -> . ID
    (27) expr -> . STRING
    (28) expr -> . FLOAT
    (29) expr -> . INT
    (30) expr -> . expr '
    (31) expr -> . - expr
    (32) expr -> . expr GEQ expr
    (33) expr -> . expr LEQ expr
    (34) expr -> . expr > expr
    (35) expr -> . expr < expr
    (36) expr -> . expr NEQ expr
    (37) expr -> . expr EQ expr
    (38) expr -> . expr DOTDIV expr
    (39) expr -> . expr DOTMUL expr
    (40) expr -> . expr DOTSUB expr
    (41) expr -> . expr DOTADD expr
    (42) expr -> . expr / expr
    (43) expr -> . expr * expr
    (44) expr -> . expr - expr
    (45) expr -> . expr + expr
    (46) expr -> . [ expr_list ]
    (47) expr -> . expr [ expr_list ]
    (               shift and go to state 11
    EYE             shift and go to state 15
    ONES            shift and go to state 16
    ZEROS           shift and go to state 17
    ID              shift and go to state 9
    STRING          shift and go to state 18
    FLOAT           shift and go to state 19
    INT             shift and go to state 20
    -               shift and go to state 21
    [               shift and go to state 22

    expr_list                      shift and go to state 92
    expr                           shift and go to state 54

state 60

    (31) expr -> - expr .
    (30) expr -> expr . '
    (32) expr -> expr . GEQ expr
    (33) expr -> expr . LEQ expr
    (34) expr -> expr . > expr
    (35) expr -> expr . < expr
    (36) expr -> expr . NEQ expr
    (37) expr -> expr . EQ expr
    (38) expr -> expr . DOTDIV expr
    (39) expr -> expr . DOTMUL expr
    (40) expr -> expr . DOTSUB expr
    (41) expr -> expr . DOTADD expr
    (42) expr -> expr . / expr
    (43) expr -> expr . * expr
    (44) expr -> expr . - expr
    (45) expr -> expr . + expr
    (47) expr -> expr . [ expr_list ]
    DIVASSIGN       reduce using rule 31 (expr -> - expr .)
    MULASSIGN       reduce using rule 31 (expr -> - expr .)
    SUBASSIGN       reduce using rule 31 (expr -> - expr .)
    ADDASSIGN       reduce using rule 31 (expr -> - expr .)
    =               reduce using rule 31 (expr -> - expr .)
    ;               reduce using rule 31 (expr -> - expr .)
    '               reduce using rule 31 (expr -> - expr .)
    GEQ             reduce using rule 31 (expr -> - expr .)
    LEQ             reduce using rule 31 (expr -> - expr .)
    >               reduce using rule 31 (expr -> - expr .)
    <               reduce using rule 31 (expr -> - expr .)
    NEQ             reduce using rule 31 (expr -> - expr .)
    EQ              reduce using rule 31 (expr -> - expr .)
    DOTDIV          reduce using rule 31 (expr -> - expr .)
    DOTMUL          reduce using rule 31 (expr -> - expr .)
    DOTSUB          reduce using rule 31 (expr -> - expr .)
    DOTADD          reduce using rule 31 (expr -> - expr .)
    /               reduce using rule 31 (expr -> - expr .)
    *               reduce using rule 31 (expr -> - expr .)
    -               reduce using rule 31 (expr -> - expr .)
    +               reduce using rule 31 (expr -> - expr .)
    [               reduce using rule 31 (expr -> - expr .)
    )               reduce using rule 31 (expr -> - expr .)
    ,               reduce using rule 31 (expr -> - expr .)
    ]               reduce using rule 31 (expr -> - expr .)
    :               reduce using rule 31 (expr -> - expr .)
    RETURN          reduce using rule 31 (expr -> - expr .)
    CONTINUE        reduce using rule 31 (expr -> - expr .)
    BREAK           reduce using rule 31 (expr -> - expr .)
    FOR             reduce using rule 31 (expr -> - expr .)
    WHILE           reduce using rule 31 (expr -> - expr .)
    IF              reduce using rule 31 (expr -> - expr .)
    PRINT           reduce using rule 31 (expr -> - expr .)
    {               reduce using rule 31 (expr -> - expr .)
    (               reduce using rule 31 (expr -> - expr .)
    EYE             reduce using rule 31 (expr -> - expr .)
    ONES            reduce using rule 31 (expr -> - expr .)
    ZEROS           reduce using rule 31 (expr -> - expr .)
    ID              reduce using rule 31 (expr -> - expr .)
    STRING          reduce using rule 31 (expr -> - expr .)
    FLOAT           reduce using rule 31 (expr -> - expr .)
    INT             reduce using rule 31 (expr -> - expr .)


state 61

    (46) expr -> [ expr_list . ]
    ]               shift and go to state 93


state 62

    (4) stmt -> RETURN expr ; .
    RETURN          reduce using rule 4 (stmt -> RETURN expr ; .)
    CONTINUE        reduce using rule 4 (stmt -> RETURN expr ; .)
    BREAK           reduce using rule 4 (stmt -> RETURN expr ; .)
    FOR             reduce using rule 4 (stmt -> RETURN expr ; .)
    WHILE           reduce using rule 4 (stmt -> RETURN expr ; .)
    IF              reduce using rule 4 (stmt -> RETURN expr ; .)
    PRINT           reduce using rule 4 (stmt -> RETURN expr ; .)
    {               reduce using rule 4 (stmt -> RETURN expr ; .)
    (               reduce using rule 4 (stmt -> RETURN expr ; .)
    EYE             reduce using rule 4 (stmt -> RETURN expr ; .)
    ONES            reduce using rule 4 (stmt -> RETURN expr ; .)
    ZEROS           reduce using rule 4 (stmt -> RETURN expr ; .)
    ID              reduce using rule 4 (stmt -> RETURN expr ; .)
    STRING          reduce using rule 4 (stmt -> RETURN expr ; .)
    FLOAT           reduce using rule 4 (stmt -> RETURN expr ; .)
    INT             reduce using rule 4 (stmt -> RETURN expr ; .)
    -               reduce using rule 4 (stmt -> RETURN expr ; .)
    [               reduce using rule 4 (stmt -> RETURN expr ; .)
    $end            reduce using rule 4 (stmt -> RETURN expr ; .)
    }               reduce using rule 4 (stmt -> RETURN expr ; .)
    ELSE            reduce using rule 4 (stmt -> RETURN expr ; .)


state 63

    (12) stmt -> expr DIVASSIGN expr . ;
    (30) expr -> expr . '
    (32) expr -> expr . GEQ expr
    (33) expr -> expr . LEQ expr
    (34) expr -> expr . > expr
    (35) expr -> expr . < expr
    (36) expr -> expr . NEQ expr
    (37) expr -> expr . EQ expr
    (38) expr -> expr . DOTDIV expr
    (39) expr -> expr . DOTMUL expr
    (40) expr -> expr . DOTSUB expr
    (41) expr -> expr . DOTADD expr
    (42) expr -> expr . / expr
    (43) expr -> expr . * expr
    (44) expr -> expr . - expr
    (45) expr -> expr . + expr
    (47) expr -> expr . [ expr_list ]
    ;               shift and go to state 94
    '               shift and go to state 31
    GEQ             shift and go to state 32
    LEQ             shift and go to state 33
    >               shift and go to state 34
    <               shift and go to state 35
    NEQ             shift and go to state 36
    EQ              shift and go to state 37
    DOTDIV          shift and go to state 38
    DOTMUL          shift and go to state 39
    DOTSUB          shift and go to state 40
    DOTADD          shift and go to state 41
    /               shift and go to state 42
    *               shift and go to state 43
    -               shift and go to state 44
    +               shift and go to state 45
    [               shift and go to state 46


state 64

    (13) stmt -> expr MULASSIGN expr . ;
    (30) expr -> expr . '
    (32) expr -> expr . GEQ expr
    (33) expr -> expr . LEQ expr
    (34) expr -> expr . > expr
    (35) expr -> expr . < expr
    (36) expr -> expr . NEQ expr
    (37) expr -> expr . EQ expr
    (38) expr -> expr . DOTDIV expr
    (39) expr -> expr . DOTMUL expr
    (40) expr -> expr . DOTSUB expr
    (41) expr -> expr . DOTADD expr
    (42) expr -> expr . / expr
    (43) expr -> expr . * expr
    (44) expr -> expr . - expr
    (45) expr -> expr . + expr
    (47) expr -> expr . [ expr_list ]
    ;               shift and go to state 95
    '               shift and go to state 31
    GEQ             shift and go to state 32
    LEQ             shift and go to state 33
    >               shift and go to state 34
    <               shift and go to state 35
    NEQ             shift and go to state 36
    EQ              shift and go to state 37
    DOTDIV          shift and go to state 38
    DOTMUL          shift and go to state 39
    DOTSUB          shift and go to state 40
    DOTADD          shift and go to state 41
    /               shift and go to state 42
    *               shift and go to state 43
    -               shift and go to state 44
    +               shift and go to state 45
    [               shift and go to state 46


state 65

    (14) stmt -> expr SUBASSIGN expr . ;
    (30) expr -> expr . '
    (32) expr -> expr . GEQ expr
    (33) expr -> expr . LEQ expr
    (34) expr -> expr . > expr
    (35) expr -> expr . < expr
    (36) expr -> expr . NEQ expr
    (37) expr -> expr . EQ expr
    (38) expr -> expr . DOTDIV expr
    (39) expr -> expr . DOTMUL expr
    (40) expr -> expr . DOTSUB expr
    (41) expr -> expr . DOTADD expr
    (42) expr -> expr . / expr
    (43) expr -> expr . * expr
    (44) expr -> expr . - expr
    (45) expr -> expr . + expr
    (47) expr -> expr . [ expr_list ]
    ;               shift and go to state 96
    '               shift and go to state 31
    GEQ             shift and go to state 32
    LEQ             shift and go to state 33
    >               shift and go to state 34
    <               shift and go to state 35
    NEQ             shift and go to state 36
    EQ              shift and go to state 37
    DOTDIV          shift and go to state 38
    DOTMUL          shift and go to state 39
    DOTSUB          shift and go to state 40
    DOTADD          shift and go to state 41
    /               shift and go to state 42
    *               shift and go to state 43
    -               shift and go to state 44
    +               shift and go to state 45
    [               shift and go to state 46


state 66

    (15) stmt -> expr ADDASSIGN expr . ;
    (30) expr -> expr . '
    (32) expr -> expr . GEQ expr
    (33) expr -> expr . LEQ expr
    (34) expr -> expr . > expr
    (35) expr -> expr . < expr
    (36) expr -> expr . NEQ expr
    (37) expr -> expr . EQ expr
    (38) expr -> expr . DOTDIV expr
    (39) expr -> expr . DOTMUL expr
    (40) expr -> expr . DOTSUB expr
    (41) expr -> expr . DOTADD expr
    (42) expr -> expr . / expr
    (43) expr -> expr . * expr
    (44) expr -> expr . - expr
    (45) expr -> expr . + expr
    (47) expr -> expr . [ expr_list ]
    ;               shift and go to state 97
    '               shift and go to state 31
    GEQ             shift and go to state 32
    LEQ             shift and go to state 33
    >               shift and go to state 34
    <               shift and go to state 35
    NEQ             shift and go to state 36
    EQ              shift and go to state 37
    DOTDIV          shift and go to state 38
    DOTMUL          shift and go to state 39
    DOTSUB          shift and go to state 40
    DOTADD          shift and go to state 41
    /               shift and go to state 42
    *               shift and go to state 43
    -               shift and go to state 44
    +               shift and go to state 45
    [               shift and go to state 46


state 67

    (16) stmt -> expr = expr . ;
    (30) expr -> expr . '
    (32) expr -> expr . GEQ expr
    (33) expr -> expr . LEQ expr
    (34) expr -> expr . > expr
    (35) expr -> expr . < expr
    (36) expr -> expr . NEQ expr
    (37) expr -> expr . EQ expr
    (38) expr -> expr . DOTDIV expr
    (39) expr -> expr . DOTMUL expr
    (40) expr -> expr . DOTSUB expr
    (41) expr -> expr . DOTADD expr
    (42) expr -> expr . / expr
    (43) expr -> expr . * expr
    (44) expr -> expr . - expr
    (45) expr -> expr . + expr
    (47) expr -> expr . [ expr_list ]
    ;               shift and go to state 98
    '               shift and go to state 31
    GEQ             shift and go to state 32
    LEQ             shift and go to state 33
    >               shift and go to state 34
    <               shift and go to state 35
    NEQ             shift and go to state 36
    EQ              shift and go to state 37
    DOTDIV          shift and go to state 38
    DOTMUL          shift and go to state 39
    DOTSUB          shift and go to state 40
    DOTADD          shift and go to state 41
    /               shift and go to state 42
    *               shift and go to state 43
    -               shift and go to state 44
    +               shift and go to state 45
    [               shift and go to state 46


state 68

    (32) expr -> expr GEQ expr .
    (30) expr -> expr . '
    (32) expr -> expr . GEQ expr
    (33) expr -> expr . LEQ expr
    (34) expr -> expr . > expr
    (35) expr -> expr . < expr
    (36) expr -> expr . NEQ expr
    (37) expr -> expr . EQ expr
    (38) expr -> expr . DOTDIV expr
    (39) expr -> expr . DOTMUL expr
    (40) expr -> expr . DOTSUB expr
    (41) expr -> expr . DOTADD expr
    (42) expr -> expr . / expr
    (43) expr -> expr . * expr
    (44) expr -> expr . - expr
    (45) expr -> expr . + expr
    (47) expr -> expr . [ expr_list ]
    DIVASSIGN       reduce using rule 32 (expr -> expr GEQ expr .)
    MULASSIGN       reduce using rule 32 (expr -> expr GEQ expr .)
    SUBASSIGN       reduce using rule 32 (expr -> expr GEQ expr .)
    ADDASSIGN       reduce using rule 32 (expr -> expr GEQ expr .)
    =               reduce using rule 32 (expr -> expr GEQ expr .)
    ;               reduce using rule 32 (expr -> expr GEQ expr .)
    '               reduce using rule 32 (expr -> expr GEQ expr .)
    GEQ             reduce using rule 32 (expr -> expr GEQ expr .)
    LEQ             reduce using rule 32 (expr -> expr GEQ expr .)
    >               reduce using rule 32 (expr -> expr GEQ expr .)
    <               reduce using rule 32 (expr -> expr GEQ expr .)
    NEQ             reduce using rule 32 (expr -> expr GEQ expr .)
    EQ              reduce using rule 32 (expr -> expr GEQ expr .)
    [               reduce using rule 32 (expr -> expr GEQ expr .)
    )               reduce using rule 32 (expr -> expr GEQ expr .)
    ,               reduce using rule 32 (expr -> expr GEQ expr .)
    ]               reduce using rule 32 (expr -> expr GEQ expr .)
    :               reduce using rule 32 (expr -> expr GEQ expr .)
    RETURN          reduce using rule 32 (expr -> expr GEQ expr .)
    CONTINUE        reduce using rule 32 (expr -> expr GEQ expr .)
    BREAK           reduce using rule 32 (expr -> expr GEQ expr .)
    FOR             reduce using rule 32 (expr -> expr GEQ expr .)
    WHILE           reduce using rule 32 (expr -> expr GEQ expr .)
    IF              reduce using rule 32 (expr -> expr GEQ expr .)
    PRINT           reduce using rule 32 (expr -> expr GEQ expr .)
    {               reduce using rule 32 (expr -> expr GEQ expr .)
    (               reduce using rule 32 (expr -> expr GEQ expr .)
    EYE             reduce using rule 32 (expr -> expr GEQ expr .)
    ONES            reduce using rule 32 (expr -> expr GEQ expr .)
    ZEROS           reduce using rule 32 (expr -> expr GEQ expr .)
    ID              reduce using rule 32 (expr -> expr GEQ expr .)
    STRING          reduce using rule 32 (expr -> expr GEQ expr .)
    FLOAT           reduce using rule 32 (expr -> expr GEQ expr .)
    INT             reduce using rule 32 (expr -> expr GEQ expr .)
    DOTDIV          shift and go to state 38
    DOTMUL          shift and go to state 39
    DOTSUB          shift and go to state 40
    DOTADD          shift and go to state 41
    /               shift and go to state 42
    *               shift and go to state 43
    -               shift and go to state 44
    +               shift and go to state 45


state 69

    (33) expr -> expr LEQ expr .
    (30) expr -> expr . '
    (32) expr -> expr . GEQ expr
    (33) expr -> expr . LEQ expr
    (34) expr -> expr . > expr
    (35) expr -> expr . < expr
    (36) expr -> expr . NEQ expr
    (37) expr -> expr . EQ expr
    (38) expr -> expr . DOTDIV expr
    (39) expr -> expr . DOTMUL expr
    (40) expr -> expr . DOTSUB expr
    (41) expr -> expr . DOTADD expr
    (42) expr -> expr . / expr
    (43) expr -> expr . * expr
    (44) expr -> expr . - expr
    (45) expr -> expr . + expr
    (47) expr -> expr . [ expr_list ]
    DIVASSIGN       reduce using rule 33 (expr -> expr LEQ expr .)
    MULASSIGN       reduce using rule 33 (expr -> expr LEQ expr .)
    SUBASSIGN       reduce using rule 33 (expr -> expr LEQ expr .)
    ADDASSIGN       reduce using rule 33 (expr -> expr LEQ expr .)
    =               reduce using rule 33 (expr -> expr LEQ expr .)
    ;               reduce using rule 33 (expr -> expr LEQ expr .)
    '               reduce using rule 33 (expr -> expr LEQ expr .)
    GEQ             reduce using rule 33 (expr -> expr LEQ expr .)
    LEQ             reduce using rule 33 (expr -> expr LEQ expr .)
    >               reduce using rule 33 (expr -> expr LEQ expr .)
    <               reduce using rule 33 (expr -> expr LEQ expr .)
    NEQ             reduce using rule 33 (expr -> expr LEQ expr .)
    EQ              reduce using rule 33 (expr -> expr LEQ expr .)
    [               reduce using rule 33 (expr -> expr LEQ expr .)
    )               reduce using rule 33 (expr -> expr LEQ expr .)
    ,               reduce using rule 33 (expr -> expr LEQ expr .)
    ]               reduce using rule 33 (expr -> expr LEQ expr .)
    :               reduce using rule 33 (expr -> expr LEQ expr .)
    RETURN          reduce using rule 33 (expr -> expr LEQ expr .)
    CONTINUE        reduce using rule 33 (expr -> expr LEQ expr .)
    BREAK           reduce using rule 33 (expr -> expr LEQ expr .)
    FOR             reduce using rule 33 (expr -> expr LEQ expr .)
    WHILE           reduce using rule 33 (expr -> expr LEQ expr .)
    IF              reduce using rule 33 (expr -> expr LEQ expr .)
    PRINT           reduce using rule 33 (expr -> expr LEQ expr .)
    {               reduce using rule 33 (expr -> expr LEQ expr .)
    (               reduce using rule 33 (expr -> expr LEQ expr .)
    EYE             reduce using rule 33 (expr -> expr LEQ expr .)
    ONES            reduce using rule 33 (expr -> expr LEQ expr .)
    ZEROS           reduce using rule 33 (expr -> expr LEQ expr .)
    ID              reduce using rule 33 (expr -> expr LEQ expr .)
    STRING          reduce using rule 33 (expr -> expr LEQ expr .)
    FLOAT           reduce using rule 33 (expr -> expr LEQ expr .)
    INT             reduce using rule 33 (expr -> expr LEQ expr .)
    DOTDIV          shift and go to state 38
    DOTMUL          shift and go to state 39
    DOTSUB          shift and go to state 40
    DOTADD          shift and go to state 41
    /               shift and go to state 42
    *               shift and go to state 43
    -               shift and go to state 44
    +               shift and go to state 45


state 70

    (34) expr -> expr > expr .
    (30) expr -> expr . '
    (32) expr -> expr . GEQ expr
    (33) expr -> expr . LEQ expr
    (34) expr -> expr . > expr
    (35) expr -> expr . < expr
    (36) expr -> expr . NEQ expr
    (37) expr -> expr . EQ expr
    (38) expr -> expr . DOTDIV expr
    (39) expr -> expr . DOTMUL expr
    (40) expr -> expr . DOTSUB expr
    (41) expr -> expr . DOTADD expr
    (42) expr -> expr . / expr
    (43) expr -> expr . * expr
    (44) expr -> expr . - expr
    (45) expr -> expr . + expr
    (47) expr -> expr . [ expr_list ]
    DIVASSIGN       reduce using rule 34 (expr -> expr > expr .)
    MULASSIGN       reduce using rule 34 (expr -> expr > expr .)
    SUBASSIGN       reduce using rule 34 (expr -> expr > expr .)
    ADDASSIGN       reduce using rule 34 (expr -> expr > expr .)
    =               reduce using rule 34 (expr -> expr > expr .)
    ;               reduce using rule 34 (expr -> expr > expr .)
    '               reduce using rule 34 (expr -> expr > expr .)
    GEQ             reduce using rule 34 (expr -> expr > expr .)
    LEQ             reduce using rule 34 (expr -> expr > expr .)
    >               reduce using rule 34 (expr -> expr > expr .)
    <               reduce using rule 34 (expr -> expr > expr .)
    NEQ             reduce using rule 34 (expr -> expr > expr .)
    EQ              reduce using rule 34 (expr -> expr > expr .)
    [               reduce using rule 34 (expr -> expr > expr .)
    )               reduce using rule 34 (expr -> expr > expr .)
    ,               reduce using rule 34 (expr -> expr > expr .)
    ]               reduce using rule 34 (expr -> expr > expr .)
    :               reduce using rule 34 (expr -> expr > expr .)
    RETURN          reduce using rule 34 (expr -> expr > expr .)
    CONTINUE        reduce using rule 34 (expr -> expr > expr .)
    BREAK           reduce using rule 34 (expr -> expr > expr .)
    FOR             reduce using rule 34 (expr -> expr > expr .)
    WHILE           reduce using rule 34 (expr -> expr > expr .)
    IF              reduce using rule 34 (expr -> expr > expr .)
    PRINT           reduce using rule 34 (expr -> expr > expr .)
    {               reduce using rule 34 (expr -> expr > expr .)
    (               reduce using rule 34 (expr -> expr > expr .)
    EYE             reduce using rule 34 (expr -> expr > expr .)
    ONES            reduce using rule 34 (expr -> expr > expr .)
    ZEROS           reduce using rule 34 (expr -> expr > expr .)
    ID              reduce using rule 34 (expr -> expr > expr .)
    STRING          reduce using rule 34 (expr -> expr > expr .)
    FLOAT           reduce using rule 34 (expr -> expr > expr .)
    INT             reduce using rule 34 (expr -> expr > expr .)
    DOTDIV          shift and go to state 38
    DOTMUL          shift and go to state 39
    DOTSUB          shift and go to state 40
    DOTADD          shift and go to state 41
    /               shift and go to state 42
    *               shift and go to state 43
    -               shift and go to state 44
    +               shift and go to state 45


state 71

    (35) expr -> expr < expr .
    (30) expr -> expr . '
    (32) expr -> expr . GEQ expr
    (33) expr -> expr . LEQ expr
    (34) expr -> expr . > expr
    (35) expr -> expr . < expr
    (36) expr -> expr . NEQ expr
    (37) expr -> expr . EQ expr
    (38) expr -> expr . DOTDIV expr
    (39) expr -> expr . DOTMUL expr
    (40) expr -> expr . DOTSUB expr
    (41) expr -> expr . DOTADD expr
    (42) expr -> expr . / expr
    (43) expr -> expr . * expr
    (44) expr -> expr . - expr
    (45) expr -> expr . + expr
    (47) expr -> expr . [ expr_list ]
    DIVASSIGN       reduce using rule 35 (expr -> expr < expr .)
    MULASSIGN       reduce using rule 35 (expr -> expr < expr .)
    SUBASSIGN       reduce using rule 35 (expr -> expr < expr .)
    ADDASSIGN       reduce using rule 35 (expr -> expr < expr .)
    =               reduce using rule 35 (expr -> expr < expr .)
    ;               reduce using rule 35 (expr -> expr < expr .)
    '               reduce using rule 35 (expr -> expr < expr .)
    GEQ             reduce using rule 35 (expr -> expr < expr .)
    LEQ             reduce using rule 35 (expr -> expr < expr .)
    >               reduce using rule 35 (expr -> expr < expr .)
    <               reduce using rule 35 (expr -> expr < expr .)
    NEQ             reduce using rule 35 (expr -> expr < expr .)
    EQ              reduce using rule 35 (expr -> expr < expr .)
    [               reduce using rule 35 (expr -> expr < expr .)
    )               reduce using rule 35 (expr -> expr < expr .)
    ,               reduce using rule 35 (expr -> expr < expr .)
    ]               reduce using rule 35 (expr -> expr < expr .)
    :               reduce using rule 35 (expr -> expr < expr .)
    RETURN          reduce using rule 35 (expr -> expr < expr .)
    CONTINUE        reduce using rule 35 (expr -> expr < expr .)
    BREAK           reduce using rule 35 (expr -> expr < expr .)
    FOR             reduce using rule 35 (expr -> expr < expr .)
    WHILE           reduce using rule 35 (expr -> expr < expr .)
    IF              reduce using rule 35 (expr -> expr < expr .)
    PRINT           reduce using rule 35 (expr -> expr < expr .)
    {               reduce using rule 35 (expr -> expr < expr .)
    (               reduce using rule 35 (expr -> expr < expr .)
    EYE             reduce using rule 35 (expr -> expr < expr .)
    ONES            reduce using rule 35 (expr -> expr < expr .)
    ZEROS           reduce using rule 35 (expr -> expr < expr .)
    ID              reduce using rule 35 (expr -> expr < expr .)
    STRING          reduce using rule 35 (expr -> expr < expr .)
    FLOAT           reduce using rule 35 (expr -> expr < expr .)
    INT             reduce using rule 35 (expr -> expr < expr .)
    DOTDIV          shift and go to state 38
    DOTMUL          shift and go to state 39
    DOTSUB          shift and go to state 40
    DOTADD          shift and go to state 41
    /               shift and go to state 42
    *               shift and go to state 43
    -               shift and go to state 44
    +               shift and go to state 45


state 72

    (36) expr -> expr NEQ expr .
    (30) expr -> expr . '
    (32) expr -> expr . GEQ expr
    (33) expr -> expr . LEQ expr
    (34) expr -> expr . > expr
    (35) expr -> expr . < expr
    (36) expr -> expr . NEQ expr
    (37) expr -> expr . EQ expr
    (38) expr -> expr . DOTDIV expr
    (39) expr -> expr . DOTMUL expr
    (40) expr -> expr . DOTSUB expr
    (41) expr -> expr . DOTADD expr
    (42) expr -> expr . / expr
    (43) expr -> expr . * expr
    (44) expr -> expr . - expr
    (45) expr -> expr . + expr
    (47) expr -> expr . [ expr_list ]
    DIVASSIGN       reduce using rule 36 (expr -> expr NEQ expr .)
    MULASSIGN       reduce using rule 36 (expr -> expr NEQ expr .)
    SUBASSIGN       reduce using rule 36 (expr -> expr NEQ expr .)
    ADDASSIGN       reduce using rule 36 (expr -> expr NEQ expr .)
    =               reduce using rule 36 (expr -> expr NEQ expr .)
    ;               reduce using rule 36 (expr -> expr NEQ expr .)
    '               reduce using rule 36 (expr -> expr NEQ expr .)
    GEQ             reduce using rule 36 (expr -> expr NEQ expr .)
    LEQ             reduce using rule 36 (expr -> expr NEQ expr .)
    >               reduce using rule 36 (expr -> expr NEQ expr .)
    <               reduce using rule 36 (expr -> expr NEQ expr .)
    NEQ             reduce using rule 36 (expr -> expr NEQ expr .)
    EQ              reduce using rule 36 (expr -> expr NEQ expr .)
    [               reduce using rule 36 (expr -> expr NEQ expr .)
    )               reduce using rule 36 (expr -> expr NEQ expr .)
    ,               reduce using rule 36 (expr -> expr NEQ expr .)
    ]               reduce using rule 36 (expr -> expr NEQ expr .)
    :               reduce using rule 36 (expr -> expr NEQ expr .)
    RETURN          reduce using rule 36 (expr -> expr NEQ expr .)
    CONTINUE        reduce using rule 36 (expr -> expr NEQ expr .)
    BREAK           reduce using rule 36 (expr -> expr NEQ expr .)
    FOR             reduce using rule 36 (expr -> expr NEQ expr .)
    WHILE           reduce using rule 36 (expr -> expr NEQ expr .)
    IF              reduce using rule 36 (expr -> expr NEQ expr .)
    PRINT           reduce using rule 36 (expr -> expr NEQ expr .)
    {               reduce using rule 36 (expr -> expr NEQ expr .)
    (               reduce using rule 36 (expr -> expr NEQ expr .)
    EYE             reduce using rule 36 (expr -> expr NEQ expr .)
    ONES            reduce using rule 36 (expr -> expr NEQ expr .)
    ZEROS           reduce using rule 36 (expr -> expr NEQ expr .)
    ID              reduce using rule 36 (expr -> expr NEQ expr .)
    STRING          reduce using rule 36 (expr -> expr NEQ expr .)
    FLOAT           reduce using rule 36 (expr -> expr NEQ expr .)
    INT             reduce using rule 36 (expr -> expr NEQ expr .)
    DOTDIV          shift and go to state 38
    DOTMUL          shift and go to state 39
    DOTSUB          shift and go to state 40
    DOTADD          shift and go to state 41
    /               shift and go to state 42
    *               shift and go to state 43
    -               shift and go to state 44
    +               shift and go to state 45


state 73

    (37) expr -> expr EQ expr .
    (30) expr -> expr . '
    (32) expr -> expr . GEQ expr
    (33) expr -> expr . LEQ expr
    (34) expr -> expr . > expr
    (35) expr -> expr . < expr
    (36) expr -> expr . NEQ expr
    (37) expr -> expr . EQ expr
    (38) expr -> expr . DOTDIV expr
    (39) expr -> expr . DOTMUL expr
    (40) expr -> expr . DOTSUB expr
    (41) expr -> expr . DOTADD expr
    (42) expr -> expr . / expr
    (43) expr -> expr . * expr
    (44) expr -> expr . - expr
    (45) expr -> expr . + expr
    (47) expr -> expr . [ expr_list ]
    DIVASSIGN       reduce using rule 37 (expr -> expr EQ expr .)
    MULASSIGN       reduce using rule 37 (expr -> expr EQ expr .)
    SUBASSIGN       reduce using rule 37 (expr -> expr EQ expr .)
    ADDASSIGN       reduce using rule 37 (expr -> expr EQ expr .)
    =               reduce using rule 37 (expr -> expr EQ expr .)
    ;               reduce using rule 37 (expr -> expr EQ expr .)
    '               reduce using rule 37 (expr -> expr EQ expr .)
    GEQ             reduce using rule 37 (expr -> expr EQ expr .)
    LEQ             reduce using rule 37 (expr -> expr EQ expr .)
    >               reduce using rule 37 (expr -> expr EQ expr .)
    <               reduce using rule 37 (expr -> expr EQ expr .)
    NEQ             reduce using rule 37 (expr -> expr EQ expr .)
    EQ              reduce using rule 37 (expr -> expr EQ expr .)
    [               reduce using rule 37 (expr -> expr EQ expr .)
    )               reduce using rule 37 (expr -> expr EQ expr .)
    ,               reduce using rule 37 (expr -> expr EQ expr .)
    ]               reduce using rule 37 (expr -> expr EQ expr .)
    :               reduce using rule 37 (expr -> expr EQ expr .)
    RETURN          reduce using rule 37 (expr -> expr EQ expr .)
    CONTINUE        reduce using rule 37 (expr -> expr EQ expr .)
    BREAK           reduce using rule 37 (expr -> expr EQ expr .)
    FOR             reduce using rule 37 (expr -> expr EQ expr .)
    WHILE           reduce using rule 37 (expr -> expr EQ expr .)
    IF              reduce using rule 37 (expr -> expr EQ expr .)
    PRINT           reduce using rule 37 (expr -> expr EQ expr .)
    {               reduce using rule 37 (expr -> expr EQ expr .)
    (               reduce using rule 37 (expr -> expr EQ expr .)
    EYE             reduce using rule 37 (expr -> expr EQ expr .)
    ONES            reduce using rule 37 (expr -> expr EQ expr .)
    ZEROS           reduce using rule 37 (expr -> expr EQ expr .)
    ID              reduce using rule 37 (expr -> expr EQ expr .)
    STRING          reduce using rule 37 (expr -> expr EQ expr .)
    FLOAT           reduce using rule 37 (expr -> expr EQ expr .)
    INT             reduce using rule 37 (expr -> expr EQ expr .)
    DOTDIV          shift and go to state 38
    DOTMUL          shift and go to state 39
    DOTSUB          shift and go to state 40
    DOTADD          shift and go to state 41
    /               shift and go to state 42
    *               shift and go to state 43
    -               shift and go to state 44
    +               shift and go to state 45


state 74

    (38) expr -> expr DOTDIV expr .
    (30) expr -> expr . '
    (32) expr -> expr . GEQ expr
    (33) expr -> expr . LEQ expr
    (34) expr -> expr . > expr
    (35) expr -> expr . < expr
    (36) expr -> expr . NEQ expr
    (37) expr -> expr . EQ expr
    (38) expr -> expr . DOTDIV expr
    (39) expr -> expr . DOTMUL expr
    (40) expr -> expr . DOTSUB expr
    (41) expr -> expr . DOTADD expr
    (42) expr -> expr . / expr
    (43) expr -> expr . * expr
    (44) expr -> expr . - expr
    (45) expr -> expr . + expr
    (47) expr -> expr . [ expr_list ]
    DIVASSIGN       reduce using rule 38 (expr -> expr DOTDIV expr .)
    MULASSIGN       reduce using rule 38 (expr -> expr DOTDIV expr .)
    SUBASSIGN       reduce using rule 38 (expr -> expr DOTDIV expr .)
    ADDASSIGN       reduce using rule 38 (expr -> expr DOTDIV expr .)
    =               reduce using rule 38 (expr -> expr DOTDIV expr .)
    ;               reduce using rule 38 (expr -> expr DOTDIV expr .)
    '               reduce using rule 38 (expr -> expr DOTDIV expr .)
    GEQ             reduce using rule 38 (expr -> expr DOTDIV expr .)
    LEQ             reduce using rule 38 (expr -> expr DOTDIV expr .)
    >               reduce using rule 38 (expr -> expr DOTDIV expr .)
    <               reduce using rule 38 (expr -> expr DOTDIV expr .)
    NEQ             reduce using rule 38 (expr -> expr DOTDIV expr .)
    EQ              reduce using rule 38 (expr -> expr DOTDIV expr .)
    DOTDIV          reduce using rule 38 (expr -> expr DOTDIV expr .)
    DOTMUL          reduce using rule 38 (expr -> expr DOTDIV expr .)
    DOTSUB          reduce using rule 38 (expr -> expr DOTDIV expr .)
    DOTADD          reduce using rule 38 (expr -> expr DOTDIV expr .)
    /               reduce using rule 38 (expr -> expr DOTDIV expr .)
    *               reduce using rule 38 (expr -> expr DOTDIV expr .)
    -               reduce using rule 38 (expr -> expr DOTDIV expr .)
    +               reduce using rule 38 (expr -> expr DOTDIV expr .)
    [               reduce using rule 38 (expr -> expr DOTDIV expr .)
    )               reduce using rule 38 (expr -> expr DOTDIV expr .)
    ,               reduce using rule 38 (expr -> expr DOTDIV expr .)
    ]               reduce using rule 38 (expr -> expr DOTDIV expr .)
    :               reduce using rule 38 (expr -> expr DOTDIV expr .)
    RETURN          reduce using rule 38 (expr -> expr DOTDIV expr .)
    CONTINUE        reduce using rule 38 (expr -> expr DOTDIV expr .)
    BREAK           reduce using rule 38 (expr -> expr DOTDIV expr .)
    FOR             reduce using rule 38 (expr -> expr DOTDIV expr .)
    WHILE           reduce using rule 38 (expr -> expr DOTDIV expr .)
    IF              reduce using rule 38 (expr -> expr DOTDIV expr .)
    PRINT           reduce using rule 38 (expr -> expr DOTDIV expr .)
    {               reduce using rule 38 (expr -> expr DOTDIV expr .)
    (               reduce using rule 38 (expr -> expr DOTDIV expr .)
    EYE             reduce using rule 38 (expr -> expr DOTDIV expr .)
    ONES            reduce using rule 38 (expr -> expr DOTDIV expr .)
    ZEROS           reduce using rule 38 (expr -> expr DOTDIV expr .)
    ID              reduce using rule 38 (expr -> expr DOTDIV expr .)
    STRING          reduce using rule 38 (expr -> expr DOTDIV expr .)
    FLOAT           reduce using rule 38 (expr -> expr DOTDIV expr .)
    INT             reduce using rule 38 (expr -> expr DOTDIV expr .)


state 75

    (39) expr -> expr DOTMUL expr .
    (30) expr -> expr . '
    (32) expr -> expr . GEQ expr
    (33) expr -> expr . LEQ expr
    (34) expr -> expr . > expr
    (35) expr -> expr . < expr
    (36) expr -> expr . NEQ expr
    (37) expr -> expr . EQ expr
    (38) expr -> expr . DOTDIV expr
    (39) expr -> expr . DOTMUL expr
    (40) expr -> expr . DOTSUB expr
    (41) expr -> expr . DOTADD expr
    (42) expr -> expr . / expr
    (43) expr -> expr . * expr
    (44) expr -> expr . - expr
    (45) expr -> expr . + expr
    (47) expr -> expr . [ expr_list ]
    DIVASSIGN       reduce using rule 39 (expr -> expr DOTMUL expr .)
    MULASSIGN       reduce using rule 39 (expr -> expr DOTMUL expr .)
    SUBASSIGN       reduce using rule 39 (expr -> expr DOTMUL expr .)
    ADDASSIGN       reduce using rule 39 (expr -> expr DOTMUL expr .)
    =               reduce using rule 39 (expr -> expr DOTMUL expr .)
    ;               reduce using rule 39 (expr -> expr DOTMUL expr .)
    '               reduce using rule 39 (expr -> expr DOTMUL expr .)
    GEQ             reduce using rule 39 (expr -> expr DOTMUL expr .)
    LEQ             reduce using rule 39 (expr -> expr DOTMUL expr .)
    >               reduce using rule 39 (expr -> expr DOTMUL expr .)
    <               reduce using rule 39 (expr -> expr DOTMUL expr .)
    NEQ             reduce using rule 39 (expr -> expr DOTMUL expr .)
    EQ              reduce using rule 39 (expr -> expr DOTMUL expr .)
    DOTDIV          reduce using rule 39 (expr -> expr DOTMUL expr .)
    DOTMUL          reduce using rule 39 (expr -> expr DOTMUL expr .)
    DOTSUB          reduce using rule 39 (expr -> expr DOTMUL expr .)
    DOTADD          reduce using rule 39 (expr -> expr DOTMUL expr .)
    /               reduce using rule 39 (expr -> expr DOTMUL expr .)
    *               reduce using rule 39 (expr -> expr DOTMUL expr .)
    -               reduce using rule 39 (expr -> expr DOTMUL expr .)
    +               reduce using rule 39 (expr -> expr DOTMUL expr .)
    [               reduce using rule 39 (expr -> expr DOTMUL expr .)
    )               reduce using rule 39 (expr -> expr DOTMUL expr .)
    ,               reduce using rule 39 (expr -> expr DOTMUL expr .)
    ]               reduce using rule 39 (expr -> expr DOTMUL expr .)
    :               reduce using rule 39 (expr -> expr DOTMUL expr .)
    RETURN          reduce using rule 39 (expr -> expr DOTMUL expr .)
    CONTINUE        reduce using rule 39 (expr -> expr DOTMUL expr .)
    BREAK           reduce using rule 39 (expr -> expr DOTMUL expr .)
    FOR             reduce using rule 39 (expr -> expr DOTMUL expr .)
    WHILE           reduce using rule 39 (expr -> expr DOTMUL expr .)
    IF              reduce using rule 39 (expr -> expr DOTMUL expr .)
    PRINT           reduce using rule 39 (expr -> expr DOTMUL expr .)
    {               reduce using rule 39 (expr -> expr DOTMUL expr .)
    (               reduce using rule 39 (expr -> expr DOTMUL expr .)
    EYE             reduce using rule 39 (expr -> expr DOTMUL expr .)
    ONES            reduce using rule 39 (expr -> expr DOTMUL expr .)
    ZEROS           reduce using rule 39 (expr -> expr DOTMUL expr .)
    ID              reduce using rule 39 (expr -> expr DOTMUL expr .)
    STRING          reduce using rule 39 (expr -> expr DOTMUL expr .)
    FLOAT           reduce using rule 39 (expr -> expr DOTMUL expr .)
    INT             reduce using rule 39 (expr -> expr DOTMUL expr .)


state 76

    (40) expr -> expr DOTSUB expr .
    (30) expr -> expr . '
    (32) expr -> expr . GEQ expr
    (33) expr -> expr . LEQ expr
    (34) expr -> expr . > expr
    (35) expr -> expr . < expr
    (36) expr -> expr . NEQ expr
    (37) expr -> expr . EQ expr
    (38) expr -> expr . DOTDIV expr
    (39) expr -> expr . DOTMUL expr
    (40) expr -> expr . DOTSUB expr
    (41) expr -> expr . DOTADD expr
    (42) expr -> expr . / expr
    (43) expr -> expr . * expr
    (44) expr -> expr . - expr
    (45) expr -> expr . + expr
    (47) expr -> expr . [ expr_list ]
    DIVASSIGN       reduce using rule 40 (expr -> expr DOTSUB expr .)
    MULASSIGN       reduce using rule 40 (expr -> expr DOTSUB expr .)
    SUBASSIGN       reduce using rule 40 (expr -> expr DOTSUB expr .)
    ADDASSIGN       reduce using rule 40 (expr -> expr DOTSUB expr .)
    =               reduce using rule 40 (expr -> expr DOTSUB expr .)
    ;               reduce using rule 40 (expr -> expr DOTSUB expr .)
    '               reduce using rule 40 (expr -> expr DOTSUB expr .)
    GEQ             reduce using rule 40 (expr -> expr DOTSUB expr .)
    LEQ             reduce using rule 40 (expr -> expr DOTSUB expr .)
    >               reduce using rule 40 (expr -> expr DOTSUB expr .)
    <               reduce using rule 40 (expr -> expr DOTSUB expr .)
    NEQ             reduce using rule 40 (expr -> expr DOTSUB expr .)
    EQ              reduce using rule 40 (expr -> expr DOTSUB expr .)
    DOTSUB          reduce using rule 40 (expr -> expr DOTSUB expr .)
    DOTADD          reduce using rule 40 (expr -> expr DOTSUB expr .)
    -               reduce using rule 40 (expr -> expr DOTSUB expr .)
    +               reduce using rule 40 (expr -> expr DOTSUB expr .)
    [               reduce using rule 40 (expr -> expr DOTSUB expr .)
    )               reduce using rule 40 (expr -> expr DOTSUB expr .)
    ,               reduce using rule 40 (expr -> expr DOTSUB expr .)
    ]               reduce using rule 40 (expr -> expr DOTSUB expr .)
    :               reduce using rule 40 (expr -> expr DOTSUB expr .)
    RETURN          reduce using rule 40 (expr -> expr DOTSUB expr .)
    CONTINUE        reduce using rule 40 (expr -> expr DOTSUB expr .)
    BREAK           reduce using rule 40 (expr -> expr DOTSUB expr .)
    FOR             reduce using rule 40 (expr -> expr DOTSUB expr .)
    WHILE           reduce using rule 40 (expr -> expr DOTSUB expr .)
    IF              reduce using rule 40 (expr -> expr DOTSUB expr .)
    PRINT           reduce using rule 40 (expr -> expr DOTSUB expr .)
    {               reduce using rule 40 (expr -> expr DOTSUB expr .)
    (               reduce using rule 40 (expr -> expr DOTSUB expr .)
    EYE             reduce using rule 40 (expr -> expr DOTSUB expr .)
    ONES            reduce using rule 40 (expr -> expr DOTSUB expr .)
    ZEROS           reduce using rule 40 (expr -> expr DOTSUB expr .)
    ID              reduce using rule 40 (expr -> expr DOTSUB expr .)
    STRING          reduce using rule 40 (expr -> expr DOTSUB expr .)
    FLOAT           reduce using rule 40 (expr -> expr DOTSUB expr .)
    INT             reduce using rule 40 (expr -> expr DOTSUB expr .)
    DOTDIV          shift and go to state 38
    DOTMUL          shift and go to state 39
    /               shift and go to state 42
    *               shift and go to state 43


state 77

    (41) expr -> expr DOTADD expr .
    (30) expr -> expr . '
    (32) expr -> expr . GEQ expr
    (33) expr -> expr . LEQ expr
    (34) expr -> expr . > expr
    (35) expr -> expr . < expr
    (36) expr -> expr . NEQ expr
    (37) expr -> expr . EQ expr
    (38) expr -> expr . DOTDIV expr
    (39) expr -> expr . DOTMUL expr
    (40) expr -> expr . DOTSUB expr
    (41) expr -> expr . DOTADD expr
    (42) expr -> expr . / expr
    (43) expr -> expr . * expr
    (44) expr -> expr . - expr
    (45) expr -> expr . + expr
    (47) expr -> expr . [ expr_list ]
    DIVASSIGN       reduce using rule 41 (expr -> expr DOTADD expr .)
    MULASSIGN       reduce using rule 41 (expr -> expr DOTADD expr .)
    SUBASSIGN       reduce using rule 41 (expr -> expr DOTADD expr .)
    ADDASSIGN       reduce using rule 41 (expr -> expr DOTADD expr .)
    =               reduce using rule 41 (expr -> expr DOTADD expr .)
    ;               reduce using rule 41 (expr -> expr DOTADD expr .)
    '               reduce using rule 41 (expr -> expr DOTADD expr .)
    GEQ             reduce using rule 41 (expr -> expr DOTADD expr .)
    LEQ             reduce using rule 41 (expr -> expr DOTADD expr .)
    >               reduce using rule 41 (expr -> expr DOTADD expr .)
    <               reduce using rule 41 (expr -> expr DOTADD expr .)
    NEQ             reduce using rule 41 (expr -> expr DOTADD expr .)
    EQ              reduce using rule 41 (expr -> expr DOTADD expr .)
    DOTSUB          reduce using rule 41 (expr -> expr DOTADD expr .)
    DOTADD          reduce using rule 41 (expr -> expr DOTADD expr .)
    -               reduce using rule 41 (expr -> expr DOTADD expr .)
    +               reduce using rule 41 (expr -> expr DOTADD expr .)
    [               reduce using rule 41 (expr -> expr DOTADD expr .)
    )               reduce using rule 41 (expr -> expr DOTADD expr .)
    ,               reduce using rule 41 (expr -> expr DOTADD expr .)
    ]               reduce using rule 41 (expr -> expr DOTADD expr .)
    :               reduce using rule 41 (expr -> expr DOTADD expr .)
    RETURN          reduce using rule 41 (expr -> expr DOTADD expr .)
    CONTINUE        reduce using rule 41 (expr -> expr DOTADD expr .)
    BREAK           reduce using rule 41 (expr -> expr DOTADD expr .)
    FOR             reduce using rule 41 (expr -> expr DOTADD expr .)
    WHILE           reduce using rule 41 (expr -> expr DOTADD expr .)
    IF              reduce using rule 41 (expr -> expr DOTADD expr .)
    PRINT           reduce using rule 41 (expr -> expr DOTADD expr .)
    {               reduce using rule 41 (expr -> expr DOTADD expr .)
    (               reduce using rule 41 (expr -> expr DOTADD expr .)
    EYE             reduce using rule 41 (expr -> expr DOTADD expr .)
    ONES            reduce using rule 41 (expr -> expr DOTADD expr .)
    ZEROS           reduce using rule 41 (expr -> expr DOTADD expr .)
    ID              reduce using rule 41 (expr -> expr DOTADD expr .)
    STRING          reduce using rule 41 (expr -> expr DOTADD expr .)
    FLOAT           reduce using rule 41 (expr -> expr DOTADD expr .)
    INT             reduce using rule 41 (expr -> expr DOTADD expr .)
    DOTDIV          shift and go to state 38
    DOTMUL          shift and go to state 39
    /               shift and go to state 42
    *               shift and go to state 43


state 78

    (42) expr -> expr / expr .
    (30) expr -> expr . '
    (32) expr -> expr . GEQ expr
    (33) expr -> expr . LEQ expr
    (34) expr -> expr . > expr
    (35) expr -> expr . < expr
    (36) expr -> expr . NEQ expr
    (37) expr -> expr . EQ expr
    (38) expr -> expr . DOTDIV expr
    (39) expr -> expr . DOTMUL expr
    (40) expr -> expr . DOTSUB expr
    (41) expr -> expr . DOTADD expr
    (42) expr -> expr . / expr
    (43) expr -> expr . * expr
    (44) expr -> expr . - expr
    (45) expr -> expr . + expr
    (47) expr -> expr . [ expr_list ]
    DIVASSIGN       reduce using rule 42 (expr -> expr / expr .)
    MULASSIGN       reduce using rule 42 (expr -> expr / expr .)
    SUBASSIGN       reduce using rule 42 (expr -> expr / expr .)
    ADDASSIGN       reduce using rule 42 (expr -> expr / expr .)
    =               reduce using rule 42 (expr -> expr / expr .)
    ;               reduce using rule 42 (expr -> expr / expr .)
    '               reduce using rule 42 (expr -> expr / expr .)
    GEQ             reduce using rule 42 (expr -> expr / expr .)
    LEQ             reduce using rule 42 (expr -> expr / expr .)
    >               reduce using rule 42 (expr -> expr / expr .)
    <               reduce using rule 42 (expr -> expr / expr .)
    NEQ             reduce using rule 42 (expr -> expr / expr .)
    EQ              reduce using rule 42 (expr -> expr / expr .)
    DOTDIV          reduce using rule 42 (expr -> expr / expr .)
    DOTMUL          reduce using rule 42 (expr -> expr / expr .)
    DOTSUB          reduce using rule 42 (expr -> expr / expr .)
    DOTADD          reduce using rule 42 (expr -> expr / expr .)
    /               reduce using rule 42 (expr -> expr / expr .)
    *               reduce using rule 42 (expr -> expr / expr .)
    -               reduce using rule 42 (expr -> expr / expr .)
    +               reduce using rule 42 (expr -> expr / expr .)
    [               reduce using rule 42 (expr -> expr / expr .)
    )               reduce using rule 42 (expr -> expr / expr .)
    ,               reduce using rule 42 (expr -> expr / expr .)
    ]               reduce using rule 42 (expr -> expr / expr .)
    :               reduce using rule 42 (expr -> expr / expr .)
    RETURN          reduce using rule 42 (expr -> expr / expr .)
    CONTINUE        reduce using rule 42 (expr -> expr / expr .)
    BREAK           reduce using rule 42 (expr -> expr / expr .)
    FOR             reduce using rule 42 (expr -> expr / expr .)
    WHILE           reduce using rule 42 (expr -> expr / expr .)
    IF              reduce using rule 42 (expr -> expr / expr .)
    PRINT           reduce using rule 42 (expr -> expr / expr .)
    {               reduce using rule 42 (expr -> expr / expr .)
    (               reduce using rule 42 (expr -> expr / expr .)
    EYE             reduce using rule 42 (expr -> expr / expr .)
    ONES            reduce using rule 42 (expr -> expr / expr .)
    ZEROS           reduce using rule 42 (expr -> expr / expr .)
    ID              reduce using rule 42 (expr -> expr / expr .)
    STRING          reduce using rule 42 (expr -> expr / expr .)
    FLOAT           reduce using rule 42 (expr -> expr / expr .)
    INT             reduce using rule 42 (expr -> expr / expr .)


state 79

    (43) expr -> expr * expr .
    (30) expr -> expr . '
    (32) expr -> expr . GEQ expr
    (33) expr -> expr . LEQ expr
    (34) expr -> expr . > expr
    (35) expr -> expr . < expr
    (36) expr -> expr . NEQ expr
    (37) expr -> expr . EQ expr
    (38) expr -> expr . DOTDIV expr
    (39) expr -> expr . DOTMUL expr
    (40) expr -> expr . DOTSUB expr
    (41) expr -> expr . DOTADD expr
    (42) expr -> expr . / expr
    (43) expr -> expr . * expr
    (44) expr -> expr . - expr
    (45) expr -> expr . + expr
    (47) expr -> expr . [ expr_list ]
    DIVASSIGN       reduce using rule 43 (expr -> expr * expr .)
    MULASSIGN       reduce using rule 43 (expr -> expr * expr .)
    SUBASSIGN       reduce using rule 43 (expr -> expr * expr .)
    ADDASSIGN       reduce using rule 43 (expr -> expr * expr .)
    =               reduce using rule 43 (expr -> expr * expr .)
    ;               reduce using rule 43 (expr -> expr * expr .)
    '               reduce using rule 43 (expr -> expr * expr .)
    GEQ             reduce using rule 43 (expr -> expr * expr .)
    LEQ             reduce using rule 43 (expr -> expr * expr .)
    >               reduce using rule 43 (expr -> expr * expr .)
    <               reduce using rule 43 (expr -> expr * expr .)
    NEQ             reduce using rule 43 (expr -> expr * expr .)
    EQ              reduce using rule 43 (expr -> expr * expr .)
    DOTDIV          reduce using rule 43 (expr -> expr * expr .)
    DOTMUL          reduce using rule 43 (expr -> expr * expr .)
    DOTSUB          reduce using rule 43 (expr -> expr * expr .)
    DOTADD          reduce using rule 43 (expr -> expr * expr .)
    /               reduce using rule 43 (expr -> expr * expr .)
    *               reduce using rule 43 (expr -> expr * expr .)
    -               reduce using rule 43 (expr -> expr * expr .)
    +               reduce using rule 43 (expr -> expr * expr .)
    [               reduce using rule 43 (expr -> expr * expr .)
    )               reduce using rule 43 (expr -> expr * expr .)
    ,               reduce using rule 43 (expr -> expr * expr .)
    ]               reduce using rule 43 (expr -> expr * expr .)
    :               reduce using rule 43 (expr -> expr * expr .)
    RETURN          reduce using rule 43 (expr -> expr * expr .)
    CONTINUE        reduce using rule 43 (expr -> expr * expr .)
    BREAK           reduce using rule 43 (expr -> expr * expr .)
    FOR             reduce using rule 43 (expr -> expr * expr .)
    WHILE           reduce using rule 43 (expr -> expr * expr .)
    IF              reduce using rule 43 (expr -> expr * expr .)
    PRINT           reduce using rule 43 (expr -> expr * expr .)
    {               reduce using rule 43 (expr -> expr * expr .)
    (               reduce using rule 43 (expr -> expr * expr .)
    EYE             reduce using rule 43 (expr -> expr * expr .)
    ONES            reduce using rule 43 (expr -> expr * expr .)
    ZEROS           reduce using rule 43 (expr -> expr * expr .)
    ID              reduce using rule 43 (expr -> expr * expr .)
    STRING          reduce using rule 43 (expr -> expr * expr .)
    FLOAT           reduce using rule 43 (expr -> expr * expr .)
    INT             reduce using rule 43 (expr -> expr * expr .)


state 80

    (44) expr -> expr - expr .
    (30) expr -> expr . '
    (32) expr -> expr . GEQ expr
    (33) expr -> expr . LEQ expr
    (34) expr -> expr . > expr
    (35) expr -> expr . < expr
    (36) expr -> expr . NEQ expr
    (37) expr -> expr . EQ expr
    (38) expr -> expr . DOTDIV expr
    (39) expr -> expr . DOTMUL expr
    (40) expr -> expr . DOTSUB expr
    (41) expr -> expr . DOTADD expr
    (42) expr -> expr . / expr
    (43) expr -> expr . * expr
    (44) expr -> expr . - expr
    (45) expr -> expr . + expr
    (47) expr -> expr . [ expr_list ]
    DIVASSIGN       reduce using rule 44 (expr -> expr - expr .)
    MULASSIGN       reduce using rule 44 (expr -> expr - expr .)
    SUBASSIGN       reduce using rule 44 (expr -> expr - expr .)
    ADDASSIGN       reduce using rule 44 (expr -> expr - expr .)
    =               reduce using rule 44 (expr -> expr - expr .)
    ;               reduce using rule 44 (expr -> expr - expr .)
    '               reduce using rule 44 (expr -> expr - expr .)
    GEQ             reduce using rule 44 (expr -> expr - expr .)
    LEQ             reduce using rule 44 (expr -> expr - expr .)
    >               reduce using rule 44 (expr -> expr - expr .)
    <               reduce using rule 44 (expr -> expr - expr .)
    NEQ             reduce using rule 44 (expr -> expr - expr .)
    EQ              reduce using rule 44 (expr -> expr - expr .)
    DOTSUB          reduce using rule 44 (expr -> expr - expr .)
    DOTADD          reduce using rule 44 (expr -> expr - expr .)
    -               reduce using rule 44 (expr -> expr - expr .)
    +               reduce using rule 44 (expr -> expr - expr .)
    [               reduce using rule 44 (expr -> expr - expr .)
    )               reduce using rule 44 (expr -> expr - expr .)
    ,               reduce using rule 44 (expr -> expr - expr .)
    ]               reduce using rule 44 (expr -> expr - expr .)
    :               reduce using rule 44 (expr -> expr - expr .)
    RETURN          reduce using rule 44 (expr -> expr - expr .)
    CONTINUE        reduce using rule 44 (expr -> expr - expr .)
    BREAK           reduce using rule 44 (expr -> expr - expr .)
    FOR             reduce using rule 44 (expr -> expr - expr .)
    WHILE           reduce using rule 44 (expr -> expr - expr .)
    IF              reduce using rule 44 (expr -> expr - expr .)
    PRINT           reduce using rule 44 (expr -> expr - expr .)
    {               reduce using rule 44 (expr -> expr - expr .)
    (               reduce using rule 44 (expr -> expr - expr .)
    EYE             reduce using rule 44 (expr -> expr - expr .)
    ONES            reduce using rule 44 (expr -> expr - expr .)
    ZEROS           reduce using rule 44 (expr -> expr - expr .)
    ID              reduce using rule 44 (expr -> expr - expr .)
    STRING          reduce using rule 44 (expr -> expr - expr .)
    FLOAT           reduce using rule 44 (expr -> expr - expr .)
    INT             reduce using rule 44 (expr -> expr - expr .)
    DOTDIV          shift and go to state 38
    DOTMUL          shift and go to state 39
    /               shift and go to state 42
    *               shift and go to state 43


state 81

    (45) expr -> expr + expr .
    (30) expr -> expr . '
    (32) expr -> expr . GEQ expr
    (33) expr -> expr . LEQ expr
    (34) expr -> expr . > expr
    (35) expr -> expr . < expr
    (36) expr -> expr . NEQ expr
    (37) expr -> expr . EQ expr
    (38) expr -> expr . DOTDIV expr
    (39) expr -> expr . DOTMUL expr
    (40) expr -> expr . DOTSUB expr
    (41) expr -> expr . DOTADD expr
    (42) expr -> expr . / expr
    (43) expr -> expr . * expr
    (44) expr -> expr . - expr
    (45) expr -> expr . + expr
    (47) expr -> expr . [ expr_list ]
    DIVASSIGN       reduce using rule 45 (expr -> expr + expr .)
    MULASSIGN       reduce using rule 45 (expr -> expr + expr .)
    SUBASSIGN       reduce using rule 45 (expr -> expr + expr .)
    ADDASSIGN       reduce using rule 45 (expr -> expr + expr .)
    =               reduce using rule 45 (expr -> expr + expr .)
    ;               reduce using rule 45 (expr -> expr + expr .)
    '               reduce using rule 45 (expr -> expr + expr .)
    GEQ             reduce using rule 45 (expr -> expr + expr .)
    LEQ             reduce using rule 45 (expr -> expr + expr .)
    >               reduce using rule 45 (expr -> expr + expr .)
    <               reduce using rule 45 (expr -> expr + expr .)
    NEQ             reduce using rule 45 (expr -> expr + expr .)
    EQ              reduce using rule 45 (expr -> expr + expr .)
    DOTSUB          reduce using rule 45 (expr -> expr + expr .)
    DOTADD          reduce using rule 45 (expr -> expr + expr .)
    -               reduce using rule 45 (expr -> expr + expr .)
    +               reduce using rule 45 (expr -> expr + expr .)
    [               reduce using rule 45 (expr -> expr + expr .)
    )               reduce using rule 45 (expr -> expr + expr .)
    ,               reduce using rule 45 (expr -> expr + expr .)
    ]               reduce using rule 45 (expr -> expr + expr .)
    :               reduce using rule 45 (expr -> expr + expr .)
    RETURN          reduce using rule 45 (expr -> expr + expr .)
    CONTINUE        reduce using rule 45 (expr -> expr + expr .)
    BREAK           reduce using rule 45 (expr -> expr + expr .)
    FOR             reduce using rule 45 (expr -> expr + expr .)
    WHILE           reduce using rule 45 (expr -> expr + expr .)
    IF              reduce using rule 45 (expr -> expr + expr .)
    PRINT           reduce using rule 45 (expr -> expr + expr .)
    {               reduce using rule 45 (expr -> expr + expr .)
    (               reduce using rule 45 (expr -> expr + expr .)
    EYE             reduce using rule 45 (expr -> expr + expr .)
    ONES            reduce using rule 45 (expr -> expr + expr .)
    ZEROS           reduce using rule 45 (expr -> expr + expr .)
    ID              reduce using rule 45 (expr -> expr + expr .)
    STRING          reduce using rule 45 (expr -> expr + expr .)
    FLOAT           reduce using rule 45 (expr -> expr + expr .)
    INT             reduce using rule 45 (expr -> expr + expr .)
    DOTDIV          shift and go to state 38
    DOTMUL          shift and go to state 39
    /               shift and go to state 42
    *               shift and go to state 43


state 82

    (47) expr -> expr [ expr_list . ]
    ]               shift and go to state 99


state 83

    (7) stmt -> FOR ID = . expr : expr stmt
    (22) expr -> . ( expr )
    (23) expr -> . EYE ( expr_list )
    (24) expr -> . ONES ( expr_list )
    (25) expr -> . ZEROS ( expr_list )
    (26) expr -> . ID
    (27) expr -> . STRING
    (28) expr -> . FLOAT
    (29) expr -> . INT
    (30) expr -> . expr '
    (31) expr -> . - expr
    (32) expr -> . expr GEQ expr
    (33) expr -> . expr LEQ expr
    (34) expr -> . expr > expr
    (35) expr -> . expr < expr
    (36) expr -> . expr NEQ expr
    (37) expr -> . expr EQ expr
    (38) expr -> . expr DOTDIV expr
    (39) expr -> . expr DOTMUL expr
    (40) expr -> . expr DOTSUB expr
    (41) expr -> . expr DOTADD expr
    (42) expr -> . expr / expr
    (43) expr -> . expr * expr
    (44) expr -> . expr - expr
    (45) expr -> . expr + expr
    (46) expr -> . [ expr_list ]
    (47) expr -> . expr [ expr_list ]
    (               shift and go to state 11
    EYE             shift and go to state 15
    ONES            shift and go to state 16
    ZEROS           shift and go to state 17
    ID              shift and go to state 9
    STRING          shift and go to state 18
    FLOAT           shift and go to state 19
    INT             shift and go to state 20
    -               shift and go to state 21
    [               shift and go to state 22

    expr                           shift and go to state 100

state 84

    (8) stmt -> WHILE ( expr . ) stmt
    (30) expr -> expr . '
    (32) expr -> expr . GEQ expr
    (33) expr -> expr . LEQ expr
    (34) expr -> expr . > expr
    (35) expr -> expr . < expr
    (36) expr -> expr . NEQ expr
    (37) expr -> expr . EQ expr
    (38) expr -> expr . DOTDIV expr
    (39) expr -> expr . DOTMUL expr
    (40) expr -> expr . DOTSUB expr
    (41) expr -> expr . DOTADD expr
    (42) expr -> expr . / expr
    (43) expr -> expr . * expr
    (44) expr -> expr . - expr
    (45) expr -> expr . + expr
    (47) expr -> expr . [ expr_list ]
    )               shift and go to state 101
    '               shift and go to state 31
    GEQ             shift and go to state 32
    LEQ             shift and go to state 33
    >               shift and go to state 34
    <               shift and go to state 35
    NEQ             shift and go to state 36
    EQ              shift and go to state 37
    DOTDIV          shift and go to state 38
    DOTMUL          shift and go to state 39
    DOTSUB          shift and go to state 40
    DOTADD          shift and go to state 41
    /               shift and go to state 42
    *               shift and go to state 43
    -               shift and go to state 44
    +               shift and go to state 45
    [               shift and go to state 46


state 85

    (22) expr -> ( expr ) .
    DIVASSIGN       reduce using rule 22 (expr -> ( expr ) .)
    MULASSIGN       reduce using rule 22 (expr -> ( expr ) .)
    SUBASSIGN       reduce using rule 22 (expr -> ( expr ) .)
    ADDASSIGN       reduce using rule 22 (expr -> ( expr ) .)
    =               reduce using rule 22 (expr -> ( expr ) .)
    ;               reduce using rule 22 (expr -> ( expr ) .)
    '               reduce using rule 22 (expr -> ( expr ) .)
    GEQ             reduce using rule 22 (expr -> ( expr ) .)
    LEQ             reduce using rule 22 (expr -> ( expr ) .)
    >               reduce using rule 22 (expr -> ( expr ) .)
    <               reduce using rule 22 (expr -> ( expr ) .)
    NEQ             reduce using rule 22 (expr -> ( expr ) .)
    EQ              reduce using rule 22 (expr -> ( expr ) .)
    DOTDIV          reduce using rule 22 (expr -> ( expr ) .)
    DOTMUL          reduce using rule 22 (expr -> ( expr ) .)
    DOTSUB          reduce using rule 22 (expr -> ( expr ) .)
    DOTADD          reduce using rule 22 (expr -> ( expr ) .)
    /               reduce using rule 22 (expr -> ( expr ) .)
    *               reduce using rule 22 (expr -> ( expr ) .)
    -               reduce using rule 22 (expr -> ( expr ) .)
    +               reduce using rule 22 (expr -> ( expr ) .)
    [               reduce using rule 22 (expr -> ( expr ) .)
    )               reduce using rule 22 (expr -> ( expr ) .)
    ,               reduce using rule 22 (expr -> ( expr ) .)
    ]               reduce using rule 22 (expr -> ( expr ) .)
    :               reduce using rule 22 (expr -> ( expr ) .)
    RETURN          reduce using rule 22 (expr -> ( expr ) .)
    CONTINUE        reduce using rule 22 (expr -> ( expr ) .)
    BREAK           reduce using rule 22 (expr -> ( expr ) .)
    FOR             reduce using rule 22 (expr -> ( expr ) .)
    WHILE           reduce using rule 22 (expr -> ( expr ) .)
    IF              reduce using rule 22 (expr -> ( expr ) .)
    PRINT           reduce using rule 22 (expr -> ( expr ) .)
    {               reduce using rule 22 (expr -> ( expr ) .)
    (               reduce using rule 22 (expr -> ( expr ) .)
    EYE             reduce using rule 22 (expr -> ( expr ) .)
    ONES            reduce using rule 22 (expr -> ( expr ) .)
    ZEROS           reduce using rule 22 (expr -> ( expr ) .)
    ID              reduce using rule 22 (expr -> ( expr ) .)
    STRING          reduce using rule 22 (expr -> ( expr ) .)
    FLOAT           reduce using rule 22 (expr -> ( expr ) .)
    INT             reduce using rule 22 (expr -> ( expr ) .)


state 86

    (9) stmt -> IF ( expr . ) stmt
    (10) stmt -> IF ( expr . ) stmt ELSE stmt
    (30) expr -> expr . '
    (32) expr -> expr . GEQ expr
    (33) expr -> expr . LEQ expr
    (34) expr -> expr . > expr
    (35) expr -> expr . < expr
    (36) expr -> expr . NEQ expr
    (37) expr -> expr . EQ expr
    (38) expr -> expr . DOTDIV expr
    (39) expr -> expr . DOTMUL expr
    (40) expr -> expr . DOTSUB expr
    (41) expr -> expr . DOTADD expr
    (42) expr -> expr . / expr
    (43) expr -> expr . * expr
    (44) expr -> expr . - expr
    (45) expr -> expr . + expr
    (47) expr -> expr . [ expr_list ]
    )               shift and go to state 102
    '               shift and go to state 31
    GEQ             shift and go to state 32
    LEQ             shift and go to state 33
    >               shift and go to state 34
    <               shift and go to state 35
    NEQ             shift and go to state 36
    EQ              shift and go to state 37
    DOTDIV          shift and go to state 38
    DOTMUL          shift and go to state 39
    DOTSUB          shift and go to state 40
    DOTADD          shift and go to state 41
    /               shift and go to state 42
    *               shift and go to state 43
    -               shift and go to state 44
    +               shift and go to state 45
    [               shift and go to state 46


state 87

    (11) stmt -> PRINT expr_list ; .
    RETURN          reduce using rule 11 (stmt -> PRINT expr_list ; .)
    CONTINUE        reduce using rule 11 (stmt -> PRINT expr_list ; .)
    BREAK           reduce using rule 11 (stmt -> PRINT expr_list ; .)
    FOR             reduce using rule 11 (stmt -> PRINT expr_list ; .)
    WHILE           reduce using rule 11 (stmt -> PRINT expr_list ; .)
    IF              reduce using rule 11 (stmt -> PRINT expr_list ; .)
    PRINT           reduce using rule 11 (stmt -> PRINT expr_list ; .)
    {               reduce using rule 11 (stmt -> PRINT expr_list ; .)
    (               reduce using rule 11 (stmt -> PRINT expr_list ; .)
    EYE             reduce using rule 11 (stmt -> PRINT expr_list ; .)
    ONES            reduce using rule 11 (stmt -> PRINT expr_list ; .)
    ZEROS           reduce using rule 11 (stmt -> PRINT expr_list ; .)
    ID              reduce using rule 11 (stmt -> PRINT expr_list ; .)
    STRING          reduce using rule 11 (stmt -> PRINT expr_list ; .)
    FLOAT           reduce using rule 11 (stmt -> PRINT expr_list ; .)
    INT             reduce using rule 11 (stmt -> PRINT expr_list ; .)
    -               reduce using rule 11 (stmt -> PRINT expr_list ; .)
    [               reduce using rule 11 (stmt -> PRINT expr_list ; .)
    $end            reduce using rule 11 (stmt -> PRINT expr_list ; .)
    }               reduce using rule 11 (stmt -> PRINT expr_list ; .)
    ELSE            reduce using rule 11 (stmt -> PRINT expr_list ; .)


state 88

    (21) expr_list -> expr , . expr_list
    (20) expr_list -> . expr
    (21) expr_list -> . expr , expr_list
    (22) expr -> . ( expr )
    (23) expr -> . EYE ( expr_list )
    (24) expr -> . ONES ( expr_list )
    (25) expr -> . ZEROS ( expr_list )
    (26) expr -> . ID
    (27) expr -> . STRING
    (28) expr -> . FLOAT
    (29) expr -> . INT
    (30) expr -> . expr '
    (31) expr -> . - expr
    (32) expr -> . expr GEQ expr
    (33) expr -> . expr LEQ expr
    (34) expr -> . expr > expr
    (35) expr -> . expr < expr
    (36) expr -> . expr NEQ expr
    (37) expr -> . expr EQ expr
    (38) expr -> . expr DOTDIV expr
    (39) expr -> . expr DOTMUL expr
    (40) expr -> . expr DOTSUB expr
    (41) expr -> . expr DOTADD expr
    (42) expr -> . expr / expr
    (43) expr -> . expr * expr
    (44) expr -> . expr - expr
    (45) expr -> . expr + expr
    (46) expr -> . [ expr_list ]
    (47) expr -> . expr [ expr_list ]
    (               shift and go to state 11
    EYE             shift and go to state 15
    ONES            shift and go to state 16
    ZEROS           shift and go to state 17
    ID              shift and go to state 9
    STRING          shift and go to state 18
    FLOAT           shift and go to state 19
    INT             shift and go to state 20
    -               shift and go to state 21
    [               shift and go to state 22

    expr                           shift and go to state 54
    expr_list                      shift and go to state 103

state 89

    (19) stmt -> { stmt_list } .
    RETURN          reduce using rule 19 (stmt -> { stmt_list } .)
    CONTINUE        reduce using rule 19 (stmt -> { stmt_list } .)
    BREAK           reduce using rule 19 (stmt -> { stmt_list } .)
    FOR             reduce using rule 19 (stmt -> { stmt_list } .)
    WHILE           reduce using rule 19 (stmt -> { stmt_list } .)
    IF              reduce using rule 19 (stmt -> { stmt_list } .)
    PRINT           reduce using rule 19 (stmt -> { stmt_list } .)
    {               reduce using rule 19 (stmt -> { stmt_list } .)
    (               reduce using rule 19 (stmt -> { stmt_list } .)
    EYE             reduce using rule 19 (stmt -> { stmt_list } .)
    ONES            reduce using rule 19 (stmt -> { stmt_list } .)
    ZEROS           reduce using rule 19 (stmt -> { stmt_list } .)
    ID              reduce using rule 19 (stmt -> { stmt_list } .)
    STRING          reduce using rule 19 (stmt -> { stmt_list } .)
    FLOAT           reduce using rule 19 (stmt -> { stmt_list } .)
    INT             reduce using rule 19 (stmt -> { stmt_list } .)
    -               reduce using rule 19 (stmt -> { stmt_list } .)
    [               reduce using rule 19 (stmt -> { stmt_list } .)
    $end            reduce using rule 19 (stmt -> { stmt_list } .)
    }               reduce using rule 19 (stmt -> { stmt_list } .)
    ELSE            reduce using rule 19 (stmt -> { stmt_list } .)


state 90

    (23) expr -> EYE ( expr_list . )
    )               shift and go to state 104


state 91

    (24) expr -> ONES ( expr_list . )
    )               shift and go to state 105


state 92

    (25) expr -> ZEROS ( expr_list . )
    )               shift and go to state 106


state 93

    (46) expr -> [ expr_list ] .
    DIVASSIGN       reduce using rule 46 (expr -> [ expr_list ] .)
    MULASSIGN       reduce using rule 46 (expr -> [ expr_list ] .)
    SUBASSIGN       reduce using rule 46 (expr -> [ expr_list ] .)
    ADDASSIGN       reduce using rule 46 (expr -> [ expr_list ] .)
    =               reduce using rule 46 (expr -> [ expr_list ] .)
    ;               reduce using rule 46 (expr -> [ expr_list ] .)
    '               reduce using rule 46 (expr -> [ expr_list ] .)
    GEQ             reduce using rule 46 (expr -> [ expr_list ] .)
    LEQ             reduce using rule 46 (expr -> [ expr_list ] .)
    >               reduce using rule 46 (expr -> [ expr_list ] .)
    <               reduce using rule 46 (expr -> [ expr_list ] .)
    NEQ             reduce using rule 46 (expr -> [ expr_list ] .)
    EQ              reduce using rule 46 (expr -> [ expr_list ] .)
    DOTDIV          reduce using rule 46 (expr -> [ expr_list ] .)
    DOTMUL          reduce using rule 46 (expr -> [ expr_list ] .)
    DOTSUB          reduce using rule 46 (expr -> [ expr_list ] .)
    DOTADD          reduce using rule 46 (expr -> [ expr_list ] .)
    /               reduce using rule 46 (expr -> [ expr_list ] .)
    *               reduce using rule 46 (expr -> [ expr_list ] .)
    -               reduce using rule 46 (expr -> [ expr_list ] .)
    +               reduce using rule 46 (expr -> [ expr_list ] .)
    [               reduce using rule 46 (expr -> [ expr_list ] .)
    )               reduce using rule 46 (expr -> [ expr_list ] .)
    ,               reduce using rule 46 (expr -> [ expr_list ] .)
    ]               reduce using rule 46 (expr -> [ expr_list ] .)
    :               reduce using rule 46 (expr -> [ expr_list ] .)
    RETURN          reduce using rule 46 (expr -> [ expr_list ] .)
    CONTINUE        reduce using rule 46 (expr -> [ expr_list ] .)
    BREAK           reduce using rule 46 (expr -> [ expr_list ] .)
    FOR             reduce using rule 46 (expr -> [ expr_list ] .)
    WHILE           reduce using rule 46 (expr -> [ expr_list ] .)
    IF              reduce using rule 46 (expr -> [ expr_list ] .)
    PRINT           reduce using rule 46 (expr -> [ expr_list ] .)
    {               reduce using rule 46 (expr -> [ expr_list ] .)
    (               reduce using rule 46 (expr -> [ expr_list ] .)
    EYE             reduce using rule 46 (expr -> [ expr_list ] .)
    ONES            reduce using rule 46 (expr -> [ expr_list ] .)
    ZEROS           reduce using rule 46 (expr -> [ expr_list ] .)
    ID              reduce using rule 46 (expr -> [ expr_list ] .)
    STRING          reduce using rule 46 (expr -> [ expr_list ] .)
    FLOAT           reduce using rule 46 (expr -> [ expr_list ] .)
    INT             reduce using rule 46 (expr -> [ expr_list ] .)


state 94

    (12) stmt -> expr DIVASSIGN expr ; .
    RETURN          reduce using rule 12 (stmt -> expr DIVASSIGN expr ; .)
    CONTINUE        reduce using rule 12 (stmt -> expr DIVASSIGN expr ; .)
    BREAK           reduce using rule 12 (stmt -> expr DIVASSIGN expr ; .)
    FOR             reduce using rule 12 (stmt -> expr DIVASSIGN expr ; .)
    WHILE           reduce using rule 12 (stmt -> expr DIVASSIGN expr ; .)
    IF              reduce using rule 12 (stmt -> expr DIVASSIGN expr ; .)
    PRINT           reduce using rule 12 (stmt -> expr DIVASSIGN expr ; .)
    {               reduce using rule 12 (stmt -> expr DIVASSIGN expr ; .)
    (               reduce using rule 12 (stmt -> expr DIVASSIGN expr ; .)
    EYE             reduce using rule 12 (stmt -> expr DIVASSIGN expr ; .)
    ONES            reduce using rule 12 (stmt -> expr DIVASSIGN expr ; .)
    ZEROS           reduce using rule 12 (stmt -> expr DIVASSIGN expr ; .)
    ID              reduce using rule 12 (stmt -> expr DIVASSIGN expr ; .)
    STRING          reduce using rule 12 (stmt -> expr DIVASSIGN expr ; .)
    FLOAT           reduce using rule 12 (stmt -> expr DIVASSIGN expr ; .)
    INT             reduce using rule 12 (stmt -> expr DIVASSIGN expr ; .)
    -               reduce using rule 12 (stmt -> expr DIVASSIGN expr ; .)
    [               reduce using rule 12 (stmt -> expr DIVASSIGN expr ; .)
    $end            reduce using rule 12 (stmt -> expr DIVASSIGN expr ; .)
    }               reduce using rule 12 (stmt -> expr DIVASSIGN expr ; .)
    ELSE            reduce using rule 12 (stmt -> expr DIVASSIGN expr ; .)


state 95

    (13) stmt -> expr MULASSIGN expr ; .
    RETURN          reduce using rule 13 (stmt -> expr MULASSIGN expr ; .)
    CONTINUE        reduce using rule 13 (stmt -> expr MULASSIGN expr ; .)
    BREAK           reduce using rule 13 (stmt -> expr MULASSIGN expr ; .)
    FOR             reduce using rule 13 (stmt -> expr MULASSIGN expr ; .)
    WHILE           reduce using rule 13 (stmt -> expr MULASSIGN expr ; .)
    IF              reduce using rule 13 (stmt -> expr MULASSIGN expr ; .)
    PRINT           reduce using rule 13 (stmt -> expr MULASSIGN expr ; .)
    {               reduce using rule 13 (stmt -> expr MULASSIGN expr ; .)
    (               reduce using rule 13 (stmt -> expr MULASSIGN expr ; .)
    EYE             reduce using rule 13 (stmt -> expr MULASSIGN expr ; .)
    ONES            reduce using rule 13 (stmt -> expr MULASSIGN expr ; .)
    ZEROS           reduce using rule 13 (stmt -> expr MULASSIGN expr ; .)
    ID              reduce using rule 13 (stmt -> expr MULASSIGN expr ; .)
    STRING          reduce using rule 13 (stmt -> expr MULASSIGN expr ; .)
    FLOAT           reduce using rule 13 (stmt -> expr MULASSIGN expr ; .)
    INT             reduce using rule 13 (stmt -> expr MULASSIGN expr ; .)
    -               reduce using rule 13 (stmt -> expr MULASSIGN expr ; .)
    [               reduce using rule 13 (stmt -> expr MULASSIGN expr ; .)
    $end            reduce using rule 13 (stmt -> expr MULASSIGN expr ; .)
    }               reduce using rule 13 (stmt -> expr MULASSIGN expr ; .)
    ELSE            reduce using rule 13 (stmt -> expr MULASSIGN expr ; .)


state 96

    (14) stmt -> expr SUBASSIGN expr ; .
    RETURN          reduce using rule 14 (stmt -> expr SUBASSIGN expr ; .)
    CONTINUE        reduce using rule 14 (stmt -> expr SUBASSIGN expr ; .)
    BREAK           reduce using rule 14 (stmt -> expr SUBASSIGN expr ; .)
    FOR             reduce using rule 14 (stmt -> expr SUBASSIGN expr ; .)
    WHILE           reduce using rule 14 (stmt -> expr SUBASSIGN expr ; .)
    IF              reduce using rule 14 (stmt -> expr SUBASSIGN expr ; .)
    PRINT           reduce using rule 14 (stmt -> expr SUBASSIGN expr ; .)
    {               reduce using rule 14 (stmt -> expr SUBASSIGN expr ; .)
    (               reduce using rule 14 (stmt -> expr SUBASSIGN expr ; .)
    EYE             reduce using rule 14 (stmt -> expr SUBASSIGN expr ; .)
    ONES            reduce using rule 14 (stmt -> expr SUBASSIGN expr ; .)
    ZEROS           reduce using rule 14 (stmt -> expr SUBASSIGN expr ; .)
    ID              reduce using rule 14 (stmt -> expr SUBASSIGN expr ; .)
    STRING          reduce using rule 14 (stmt -> expr SUBASSIGN expr ; .)
    FLOAT           reduce using rule 14 (stmt -> expr SUBASSIGN expr ; .)
    INT             reduce using rule 14 (stmt -> expr SUBASSIGN expr ; .)
    -               reduce using rule 14 (stmt -> expr SUBASSIGN expr ; .)
    [               reduce using rule 14 (stmt -> expr SUBASSIGN expr ; .)
    $end            reduce using rule 14 (stmt -> expr SUBASSIGN expr ; .)
    }               reduce using rule 14 (stmt -> expr SUBASSIGN expr ; .)
    ELSE            reduce using rule 14 (stmt -> expr SUBASSIGN expr ; .)


state 97

    (15) stmt -> expr ADDASSIGN expr ; .
    RETURN          reduce using rule 15 (stmt -> expr ADDASSIGN expr ; .)
    CONTINUE        reduce using rule 15 (stmt -> expr ADDASSIGN expr ; .)
    BREAK           reduce using rule 15 (stmt -> expr ADDASSIGN expr ; .)
    FOR             reduce using rule 15 (stmt -> expr ADDASSIGN expr ; .)
    WHILE           reduce using rule 15 (stmt -> expr ADDASSIGN expr ; .)
    IF              reduce using rule 15 (stmt -> expr ADDASSIGN expr ; .)
    PRINT           reduce using rule 15 (stmt -> expr ADDASSIGN expr ; .)
    {               reduce using rule 15 (stmt -> expr ADDASSIGN expr ; .)
    (               reduce using rule 15 (stmt -> expr ADDASSIGN expr ; .)
    EYE             reduce using rule 15 (stmt -> expr ADDASSIGN expr ; .)
    ONES            reduce using rule 15 (stmt -> expr ADDASSIGN expr ; .)
    ZEROS           reduce using rule 15 (stmt -> expr ADDASSIGN expr ; .)
    ID              reduce using rule 15 (stmt -> expr ADDASSIGN expr ; .)
    STRING          reduce using rule 15 (stmt -> expr ADDASSIGN expr ; .)
    FLOAT           reduce using rule 15 (stmt -> expr ADDASSIGN expr ; .)
    INT             reduce using rule 15 (stmt -> expr ADDASSIGN expr ; .)
    -               reduce using rule 15 (stmt -> expr ADDASSIGN expr ; .)
    [               reduce using rule 15 (stmt -> expr ADDASSIGN expr ; .)
    $end            reduce using rule 15 (stmt -> expr ADDASSIGN expr ; .)
    }               reduce using rule 15 (stmt -> expr ADDASSIGN expr ; .)
    ELSE            reduce using rule 15 (stmt -> expr ADDASSIGN expr ; .)


state 98

    (16) stmt -> expr = expr ; .
    RETURN          reduce using rule 16 (stmt -> expr = expr ; .)
    CONTINUE        reduce using rule 16 (stmt -> expr = expr ; .)
    BREAK           reduce using rule 16 (stmt -> expr = expr ; .)
    FOR             reduce using rule 16 (stmt -> expr = expr ; .)
    WHILE           reduce using rule 16 (stmt -> expr = expr ; .)
    IF              reduce using rule 16 (stmt -> expr = expr ; .)
    PRINT           reduce using rule 16 (stmt -> expr = expr ; .)
    {               reduce using rule 16 (stmt -> expr = expr ; .)
    (               reduce using rule 16 (stmt -> expr = expr ; .)
    EYE             reduce using rule 16 (stmt -> expr = expr ; .)
    ONES            reduce using rule 16 (stmt -> expr = expr ; .)
    ZEROS           reduce using rule 16 (stmt -> expr = expr ; .)
    ID              reduce using rule 16 (stmt -> expr = expr ; .)
    STRING          reduce using rule 16 (stmt -> expr = expr ; .)
    FLOAT           reduce using rule 16 (stmt -> expr = expr ; .)
    INT             reduce using rule 16 (stmt -> expr = expr ; .)
    -               reduce using rule 16 (stmt -> expr = expr ; .)
    [               reduce using rule 16 (stmt -> expr = expr ; .)
    $end            reduce using rule 16 (stmt -> expr = expr ; .)
    }               reduce using rule 16 (stmt -> expr = expr ; .)
    ELSE            reduce using rule 16 (stmt -> expr = expr ; .)


state 99

    (47) expr -> expr [ expr_list ] .
    DIVASSIGN       reduce using rule 47 (expr -> expr [ expr_list ] .)
    MULASSIGN       reduce using rule 47 (expr -> expr [ expr_list ] .)
    SUBASSIGN       reduce using rule 47 (expr -> expr [ expr_list ] .)
    ADDASSIGN       reduce using rule 47 (expr -> expr [ expr_list ] .)
    =               reduce using rule 47 (expr -> expr [ expr_list ] .)
    ;               reduce using rule 47 (expr -> expr [ expr_list ] .)
    '               reduce using rule 47 (expr -> expr [ expr_list ] .)
    GEQ             reduce using rule 47 (expr -> expr [ expr_list ] .)
    LEQ             reduce using rule 47 (expr -> expr [ expr_list ] .)
    >               reduce using rule 47 (expr -> expr [ expr_list ] .)
    <               reduce using rule 47 (expr -> expr [ expr_list ] .)
    NEQ             reduce using rule 47 (expr -> expr [ expr_list ] .)
    EQ              reduce using rule 47 (expr -> expr [ expr_list ] .)
    DOTDIV          reduce using rule 47 (expr -> expr [ expr_list ] .)
    DOTMUL          reduce using rule 47 (expr -> expr [ expr_list ] .)
    DOTSUB          reduce using rule 47 (expr -> expr [ expr_list ] .)
    DOTADD          reduce using rule 47 (expr -> expr [ expr_list ] .)
    /               reduce using rule 47 (expr -> expr [ expr_list ] .)
    *               reduce using rule 47 (expr -> expr [ expr_list ] .)
    -               reduce using rule 47 (expr -> expr [ expr_list ] .)
    +               reduce using rule 47 (expr -> expr [ expr_list ] .)
    [               reduce using rule 47 (expr -> expr [ expr_list ] .)
    )               reduce using rule 47 (expr -> expr [ expr_list ] .)
    ,               reduce using rule 47 (expr -> expr [ expr_list ] .)
    ]               reduce using rule 47 (expr -> expr [ expr_list ] .)
    :               reduce using rule 47 (expr -> expr [ expr_list ] .)
    RETURN          reduce using rule 47 (expr -> expr [ expr_list ] .)
    CONTINUE        reduce using rule 47 (expr -> expr [ expr_list ] .)
    BREAK           reduce using rule 47 (expr -> expr [ expr_list ] .)
    FOR             reduce using rule 47 (expr -> expr [ expr_list ] .)
    WHILE           reduce using rule 47 (expr -> expr [ expr_list ] .)
    IF              reduce using rule 47 (expr -> expr [ expr_list ] .)
    PRINT           reduce using rule 47 (expr -> expr [ expr_list ] .)
    {               reduce using rule 47 (expr -> expr [ expr_list ] .)
    (               reduce using rule 47 (expr -> expr [ expr_list ] .)
    EYE             reduce using rule 47 (expr -> expr [ expr_list ] .)
    ONES            reduce using rule 47 (expr -> expr [ expr_list ] .)
    ZEROS           reduce using rule 47 (expr -> expr [ expr_list ] .)
    ID              reduce using rule 47 (expr -> expr [ expr_list ] .)
    STRING          reduce using rule 47 (expr -> expr [ expr_list ] .)
    FLOAT           reduce using rule 47 (expr -> expr [ expr_list ] .)
    INT             reduce using rule 47 (expr -> expr [ expr_list ] .)


state 100

    (7) stmt -> FOR ID = expr . : expr stmt
    (30) expr -> expr . '
    (32) expr -> expr . GEQ expr
    (33) expr -> expr . LEQ expr
    (34) expr -> expr . > expr
    (35) expr -> expr . < expr
    (36) expr -> expr . NEQ expr
    (37) expr -> expr . EQ expr
    (38) expr -> expr . DOTDIV expr
    (39) expr -> expr . DOTMUL expr
    (40) expr -> expr . DOTSUB expr
    (41) expr -> expr . DOTADD expr
    (42) expr -> expr . / expr
    (43) expr -> expr . * expr
    (44) expr -> expr . - expr
    (45) expr -> expr . + expr
    (47) expr -> expr . [ expr_list ]
    :               shift and go to state 107
    '               shift and go to state 31
    GEQ             shift and go to state 32
    LEQ             shift and go to state 33
    >               shift and go to state 34
    <               shift and go to state 35
    NEQ             shift and go to state 36
    EQ              shift and go to state 37
    DOTDIV          shift and go to state 38
    DOTMUL          shift and go to state 39
    DOTSUB          shift and go to state 40
    DOTADD          shift and go to state 41
    /               shift and go to state 42
    *               shift and go to state 43
    -               shift and go to state 44
    +               shift and go to state 45
    [               shift and go to state 46


state 101

    (8) stmt -> WHILE ( expr ) . stmt
    (4) stmt -> . RETURN expr ;
    (5) stmt -> . CONTINUE ;
    (6) stmt -> . BREAK ;
    (7) stmt -> . FOR ID = expr : expr stmt
    (8) stmt -> . WHILE ( expr ) stmt
    (9) stmt -> . IF ( expr ) stmt
    (10) stmt -> . IF ( expr ) stmt ELSE stmt
    (11) stmt -> . PRINT expr_list ;
    (12) stmt -> . expr DIVASSIGN expr ;
    (13) stmt -> . expr MULASSIGN expr ;
    (14) stmt -> . expr SUBASSIGN expr ;
    (15) stmt -> . expr ADDASSIGN expr ;
    (16) stmt -> . expr = expr ;
    (17) stmt -> . expr ;
    (18) stmt -> . { }
    (19) stmt -> . { stmt_list }
    (22) expr -> . ( expr )
    (23) expr -> . EYE ( expr_list )
    (24) expr -> . ONES ( expr_list )
    (25) expr -> . ZEROS ( expr_list )
    (26) expr -> . ID
    (27) expr -> . STRING
    (28) expr -> . FLOAT
    (29) expr -> . INT
    (30) expr -> . expr '
    (31) expr -> . - expr
    (32) expr -> . expr GEQ expr
    (33) expr -> . expr LEQ expr
    (34) expr -> . expr > expr
    (35) expr -> . expr < expr
    (36) expr -> . expr NEQ expr
    (37) expr -> . expr EQ expr
    (38) expr -> . expr DOTDIV expr
    (39) expr -> . expr DOTMUL expr
    (40) expr -> . expr DOTSUB expr
    (41) expr -> . expr DOTADD expr
    (42) expr -> . expr / expr
    (43) expr -> . expr * expr
    (44) expr -> . expr - expr
    (45) expr -> . expr + expr
    (46) expr -> . [ expr_list ]
    (47) expr -> . expr [ expr_list ]
    RETURN          shift and go to state 4
    CONTINUE        shift and go to state 6
    BREAK           shift and go to state 7
    FOR             shift and go to state 8
    WHILE           shift and go to state 10
    IF              shift and go to state 12
    PRINT           shift and go to state 13
    {               shift and go to state 14
    (               shift and go to state 11
    EYE             shift and go to state 15
    ONES            shift and go to state 16
    ZEROS           shift and go to state 17
    ID              shift and go to state 9
    STRING          shift and go to state 18
    FLOAT           shift and go to state 19
    INT             shift and go to state 20
    -               shift and go to state 21
    [               shift and go to state 22

    expr                           shift and go to state 5
    stmt                           shift and go to state 108

state 102

    (9) stmt -> IF ( expr ) . stmt
    (10) stmt -> IF ( expr ) . stmt ELSE stmt
    (4) stmt -> . RETURN expr ;
    (5) stmt -> . CONTINUE ;
    (6) stmt -> . BREAK ;
    (7) stmt -> . FOR ID = expr : expr stmt
    (8) stmt -> . WHILE ( expr ) stmt
    (9) stmt -> . IF ( expr ) stmt
    (10) stmt -> . IF ( expr ) stmt ELSE stmt
    (11) stmt -> . PRINT expr_list ;
    (12) stmt -> . expr DIVASSIGN expr ;
    (13) stmt -> . expr MULASSIGN expr ;
    (14) stmt -> . expr SUBASSIGN expr ;
    (15) stmt -> . expr ADDASSIGN expr ;
    (16) stmt -> . expr = expr ;
    (17) stmt -> . expr ;
    (18) stmt -> . { }
    (19) stmt -> . { stmt_list }
    (22) expr -> . ( expr )
    (23) expr -> . EYE ( expr_list )
    (24) expr -> . ONES ( expr_list )
    (25) expr -> . ZEROS ( expr_list )
    (26) expr -> . ID
    (27) expr -> . STRING
    (28) expr -> . FLOAT
    (29) expr -> . INT
    (30) expr -> . expr '
    (31) expr -> . - expr
    (32) expr -> . expr GEQ expr
    (33) expr -> . expr LEQ expr
    (34) expr -> . expr > expr
    (35) expr -> . expr < expr
    (36) expr -> . expr NEQ expr
    (37) expr -> . expr EQ expr
    (38) expr -> . expr DOTDIV expr
    (39) expr -> . expr DOTMUL expr
    (40) expr -> . expr DOTSUB expr
    (41) expr -> . expr DOTADD expr
    (42) expr -> . expr / expr
    (43) expr -> . expr * expr
    (44) expr -> . expr - expr
    (45) expr -> . expr + expr
    (46) expr -> . [ expr_list ]
    (47) expr -> . expr [ expr_list ]
    RETURN          shift and go to state 4
    CONTINUE        shift and go to state 6
    BREAK           shift and go to state 7
    FOR             shift and go to state 8
    WHILE           shift and go to state 10
    IF              shift and go to state 12
    PRINT           shift and go to state 13
    {               shift and go to state 14
    (               shift and go to state 11
    EYE             shift and go to state 15
    ONES            shift and go to state 16
    ZEROS           shift and go to state 17
    ID              shift and go to state 9
    STRING          shift and go to state 18
    FLOAT           shift and go to state 19
    INT             shift and go to state 20
    -               shift and go to state 21
    [               shift and go to state 22

    expr                           shift and go to state 5
    stmt                           shift and go to state 109

state 103

    (21) expr_list -> expr , expr_list .
    ;               reduce using rule 21 (expr_list -> expr , expr_list .)
    ]               reduce using rule 21 (expr_list -> expr , expr_list .)
    )               reduce using rule 21 (expr_list -> expr , expr_list .)


state 104

    (23) expr -> EYE ( expr_list ) .
    DIVASSIGN       reduce using rule 23 (expr -> EYE ( expr_list ) .)
    MULASSIGN       reduce using rule 23 (expr -> EYE ( expr_list ) .)
    SUBASSIGN       reduce using rule 23 (expr -> EYE ( expr_list ) .)
    ADDASSIGN       reduce using rule 23 (expr -> EYE ( expr_list ) .)
    =               reduce using rule 23 (expr -> EYE ( expr_list ) .)
    ;               reduce using rule 23 (expr -> EYE ( expr_list ) .)
    '               reduce using rule 23 (expr -> EYE ( expr_list ) .)
    GEQ             reduce using rule 23 (expr -> EYE ( expr_list ) .)
    LEQ             reduce using rule 23 (expr -> EYE ( expr_list ) .)
    >               reduce using rule 23 (expr -> EYE ( expr_list ) .)
    <               reduce using rule 23 (expr -> EYE ( expr_list ) .)
    NEQ             reduce using rule 23 (expr -> EYE ( expr_list ) .)
    EQ              reduce using rule 23 (expr -> EYE ( expr_list ) .)
    DOTDIV          reduce using rule 23 (expr -> EYE ( expr_list ) .)
    DOTMUL          reduce using rule 23 (expr -> EYE ( expr_list ) .)
    DOTSUB          reduce using rule 23 (expr -> EYE ( expr_list ) .)
    DOTADD          reduce using rule 23 (expr -> EYE ( expr_list ) .)
    /               reduce using rule 23 (expr -> EYE ( expr_list ) .)
    *               reduce using rule 23 (expr -> EYE ( expr_list ) .)
    -               reduce using rule 23 (expr -> EYE ( expr_list ) .)
    +               reduce using rule 23 (expr -> EYE ( expr_list ) .)
    [               reduce using rule 23 (expr -> EYE ( expr_list ) .)
    )               reduce using rule 23 (expr -> EYE ( expr_list ) .)
    ,               reduce using rule 23 (expr -> EYE ( expr_list ) .)
    ]               reduce using rule 23 (expr -> EYE ( expr_list ) .)
    :               reduce using rule 23 (expr -> EYE ( expr_list ) .)
    RETURN          reduce using rule 23 (expr -> EYE ( expr_list ) .)
    CONTINUE        reduce using rule 23 (expr -> EYE ( expr_list ) .)
    BREAK           reduce using rule 23 (expr -> EYE ( expr_list ) .)
    FOR             reduce using rule 23 (expr -> EYE ( expr_list ) .)
    WHILE           reduce using rule 23 (expr -> EYE ( expr_list ) .)
    IF              reduce using rule 23 (expr -> EYE ( expr_list ) .)
    PRINT           reduce using rule 23 (expr -> EYE ( expr_list ) .)
    {               reduce using rule 23 (expr -> EYE ( expr_list ) .)
    (               reduce using rule 23 (expr -> EYE ( expr_list ) .)
    EYE             reduce using rule 23 (expr -> EYE ( expr_list ) .)
    ONES            reduce using rule 23 (expr -> EYE ( expr_list ) .)
    ZEROS           reduce using rule 23 (expr -> EYE ( expr_list ) .)
    ID              reduce using rule 23 (expr -> EYE ( expr_list ) .)
    STRING          reduce using rule 23 (expr -> EYE ( expr_list ) .)
    FLOAT           reduce using rule 23 (expr -> EYE ( expr_list ) .)
    INT             reduce using rule 23 (expr -> EYE ( expr_list ) .)


state 105

    (24) expr -> ONES ( expr_list ) .
    DIVASSIGN       reduce using rule 24 (expr -> ONES ( expr_list ) .)
    MULASSIGN       reduce using rule 24 (expr -> ONES ( expr_list ) .)
    SUBASSIGN       reduce using rule 24 (expr -> ONES ( expr_list ) .)
    ADDASSIGN       reduce using rule 24 (expr -> ONES ( expr_list ) .)
    =               reduce using rule 24 (expr -> ONES ( expr_list ) .)
    ;               reduce using rule 24 (expr -> ONES ( expr_list ) .)
    '               reduce using rule 24 (expr -> ONES ( expr_list ) .)
    GEQ             reduce using rule 24 (expr -> ONES ( expr_list ) .)
    LEQ             reduce using rule 24 (expr -> ONES ( expr_list ) .)
    >               reduce using rule 24 (expr -> ONES ( expr_list ) .)
    <               reduce using rule 24 (expr -> ONES ( expr_list ) .)
    NEQ             reduce using rule 24 (expr -> ONES ( expr_list ) .)
    EQ              reduce using rule 24 (expr -> ONES ( expr_list ) .)
    DOTDIV          reduce using rule 24 (expr -> ONES ( expr_list ) .)
    DOTMUL          reduce using rule 24 (expr -> ONES ( expr_list ) .)
    DOTSUB          reduce using rule 24 (expr -> ONES ( expr_list ) .)
    DOTADD          reduce using rule 24 (expr -> ONES ( expr_list ) .)
    /               reduce using rule 24 (expr -> ONES ( expr_list ) .)
    *               reduce using rule 24 (expr -> ONES ( expr_list ) .)
    -               reduce using rule 24 (expr -> ONES ( expr_list ) .)
    +               reduce using rule 24 (expr -> ONES ( expr_list ) .)
    [               reduce using rule 24 (expr -> ONES ( expr_list ) .)
    )               reduce using rule 24 (expr -> ONES ( expr_list ) .)
    ,               reduce using rule 24 (expr -> ONES ( expr_list ) .)
    ]               reduce using rule 24 (expr -> ONES ( expr_list ) .)
    :               reduce using rule 24 (expr -> ONES ( expr_list ) .)
    RETURN          reduce using rule 24 (expr -> ONES ( expr_list ) .)
    CONTINUE        reduce using rule 24 (expr -> ONES ( expr_list ) .)
    BREAK           reduce using rule 24 (expr -> ONES ( expr_list ) .)
    FOR             reduce using rule 24 (expr -> ONES ( expr_list ) .)
    WHILE           reduce using rule 24 (expr -> ONES ( expr_list ) .)
    IF              reduce using rule 24 (expr -> ONES ( expr_list ) .)
    PRINT           reduce using rule 24 (expr -> ONES ( expr_list ) .)
    {               reduce using rule 24 (expr -> ONES ( expr_list ) .)
    (               reduce using rule 24 (expr -> ONES ( expr_list ) .)
    EYE             reduce using rule 24 (expr -> ONES ( expr_list ) .)
    ONES            reduce using rule 24 (expr -> ONES ( expr_list ) .)
    ZEROS           reduce using rule 24 (expr -> ONES ( expr_list ) .)
    ID              reduce using rule 24 (expr -> ONES ( expr_list ) .)
    STRING          reduce using rule 24 (expr -> ONES ( expr_list ) .)
    FLOAT           reduce using rule 24 (expr -> ONES ( expr_list ) .)
    INT             reduce using rule 24 (expr -> ONES ( expr_list ) .)


state 106

    (25) expr -> ZEROS ( expr_list ) .
    DIVASSIGN       reduce using rule 25 (expr -> ZEROS ( expr_list ) .)
    MULASSIGN       reduce using rule 25 (expr -> ZEROS ( expr_list ) .)
    SUBASSIGN       reduce using rule 25 (expr -> ZEROS ( expr_list ) .)
    ADDASSIGN       reduce using rule 25 (expr -> ZEROS ( expr_list ) .)
    =               reduce using rule 25 (expr -> ZEROS ( expr_list ) .)
    ;               reduce using rule 25 (expr -> ZEROS ( expr_list ) .)
    '               reduce using rule 25 (expr -> ZEROS ( expr_list ) .)
    GEQ             reduce using rule 25 (expr -> ZEROS ( expr_list ) .)
    LEQ             reduce using rule 25 (expr -> ZEROS ( expr_list ) .)
    >               reduce using rule 25 (expr -> ZEROS ( expr_list ) .)
    <               reduce using rule 25 (expr -> ZEROS ( expr_list ) .)
    NEQ             reduce using rule 25 (expr -> ZEROS ( expr_list ) .)
    EQ              reduce using rule 25 (expr -> ZEROS ( expr_list ) .)
    DOTDIV          reduce using rule 25 (expr -> ZEROS ( expr_list ) .)
    DOTMUL          reduce using rule 25 (expr -> ZEROS ( expr_list ) .)
    DOTSUB          reduce using rule 25 (expr -> ZEROS ( expr_list ) .)
    DOTADD          reduce using rule 25 (expr -> ZEROS ( expr_list ) .)
    /               reduce using rule 25 (expr -> ZEROS ( expr_list ) .)
    *               reduce using rule 25 (expr -> ZEROS ( expr_list ) .)
    -               reduce using rule 25 (expr -> ZEROS ( expr_list ) .)
    +               reduce using rule 25 (expr -> ZEROS ( expr_list ) .)
    [               reduce using rule 25 (expr -> ZEROS ( expr_list ) .)
    )               reduce using rule 25 (expr -> ZEROS ( expr_list ) .)
    ,               reduce using rule 25 (expr -> ZEROS ( expr_list ) .)
    ]               reduce using rule 25 (expr -> ZEROS ( expr_list ) .)
    :               reduce using rule 25 (expr -> ZEROS ( expr_list ) .)
    RETURN          reduce using rule 25 (expr -> ZEROS ( expr_list ) .)
    CONTINUE        reduce using rule 25 (expr -> ZEROS ( expr_list ) .)
    BREAK           reduce using rule 25 (expr -> ZEROS ( expr_list ) .)
    FOR             reduce using rule 25 (expr -> ZEROS ( expr_list ) .)
    WHILE           reduce using rule 25 (expr -> ZEROS ( expr_list ) .)
    IF              reduce using rule 25 (expr -> ZEROS ( expr_list ) .)
    PRINT           reduce using rule 25 (expr -> ZEROS ( expr_list ) .)
    {               reduce using rule 25 (expr -> ZEROS ( expr_list ) .)
    (               reduce using rule 25 (expr -> ZEROS ( expr_list ) .)
    EYE             reduce using rule 25 (expr -> ZEROS ( expr_list ) .)
    ONES            reduce using rule 25 (expr -> ZEROS ( expr_list ) .)
    ZEROS           reduce using rule 25 (expr -> ZEROS ( expr_list ) .)
    ID              reduce using rule 25 (expr -> ZEROS ( expr_list ) .)
    STRING          reduce using rule 25 (expr -> ZEROS ( expr_list ) .)
    FLOAT           reduce using rule 25 (expr -> ZEROS ( expr_list ) .)
    INT             reduce using rule 25 (expr -> ZEROS ( expr_list ) .)


state 107

    (7) stmt -> FOR ID = expr : . expr stmt
    (22) expr -> . ( expr )
    (23) expr -> . EYE ( expr_list )
    (24) expr -> . ONES ( expr_list )
    (25) expr -> . ZEROS ( expr_list )
    (26) expr -> . ID
    (27) expr -> . STRING
    (28) expr -> . FLOAT
    (29) expr -> . INT
    (30) expr -> . expr '
    (31) expr -> . - expr
    (32) expr -> . expr GEQ expr
    (33) expr -> . expr LEQ expr
    (34) expr -> . expr > expr
    (35) expr -> . expr < expr
    (36) expr -> . expr NEQ expr
    (37) expr -> . expr EQ expr
    (38) expr -> . expr DOTDIV expr
    (39) expr -> . expr DOTMUL expr
    (40) expr -> . expr DOTSUB expr
    (41) expr -> . expr DOTADD expr
    (42) expr -> . expr / expr
    (43) expr -> . expr * expr
    (44) expr -> . expr - expr
    (45) expr -> . expr + expr
    (46) expr -> . [ expr_list ]
    (47) expr -> . expr [ expr_list ]
    (               shift and go to state 11
    EYE             shift and go to state 15
    ONES            shift and go to state 16
    ZEROS           shift and go to state 17
    ID              shift and go to state 9
    STRING          shift and go to state 18
    FLOAT           shift and go to state 19
    INT             shift and go to state 20
    -               shift and go to state 21
    [               shift and go to state 22

    expr                           shift and go to state 110

state 108

    (8) stmt -> WHILE ( expr ) stmt .
    RETURN          reduce using rule 8 (stmt -> WHILE ( expr ) stmt .)
    CONTINUE        reduce using rule 8 (stmt -> WHILE ( expr ) stmt .)
    BREAK           reduce using rule 8 (stmt -> WHILE ( expr ) stmt .)
    FOR             reduce using rule 8 (stmt -> WHILE ( expr ) stmt .)
    WHILE           reduce using rule 8 (stmt -> WHILE ( expr ) stmt .)
    IF              reduce using rule 8 (stmt -> WHILE ( expr ) stmt .)
    PRINT           reduce using rule 8 (stmt -> WHILE ( expr ) stmt .)
    {               reduce using rule 8 (stmt -> WHILE ( expr ) stmt .)
    (               reduce using rule 8 (stmt -> WHILE ( expr ) stmt .)
    EYE             reduce using rule 8 (stmt -> WHILE ( expr ) stmt .)
    ONES            reduce using rule 8 (stmt -> WHILE ( expr ) stmt .)
    ZEROS           reduce using rule 8 (stmt -> WHILE ( expr ) stmt .)
    ID              reduce using rule 8 (stmt -> WHILE ( expr ) stmt .)
    STRING          reduce using rule 8 (stmt -> WHILE ( expr ) stmt .)
    FLOAT           reduce using rule 8 (stmt -> WHILE ( expr ) stmt .)
    INT             reduce using rule 8 (stmt -> WHILE ( expr ) stmt .)
    -               reduce using rule 8 (stmt -> WHILE ( expr ) stmt .)
    [               reduce using rule 8 (stmt -> WHILE ( expr ) stmt .)
    $end            reduce using rule 8 (stmt -> WHILE ( expr ) stmt .)
    }               reduce using rule 8 (stmt -> WHILE ( expr ) stmt .)
    ELSE            reduce using rule 8 (stmt -> WHILE ( expr ) stmt .)


state 109

    (9) stmt -> IF ( expr ) stmt .
    (10) stmt -> IF ( expr ) stmt . ELSE stmt
    RETURN          reduce using rule 9 (stmt -> IF ( expr ) stmt .)
    CONTINUE        reduce using rule 9 (stmt -> IF ( expr ) stmt .)
    BREAK           reduce using rule 9 (stmt -> IF ( expr ) stmt .)
    FOR             reduce using rule 9 (stmt -> IF ( expr ) stmt .)
    WHILE           reduce using rule 9 (stmt -> IF ( expr ) stmt .)
    IF              reduce using rule 9 (stmt -> IF ( expr ) stmt .)
    PRINT           reduce using rule 9 (stmt -> IF ( expr ) stmt .)
    {               reduce using rule 9 (stmt -> IF ( expr ) stmt .)
    (               reduce using rule 9 (stmt -> IF ( expr ) stmt .)
    EYE             reduce using rule 9 (stmt -> IF ( expr ) stmt .)
    ONES            reduce using rule 9 (stmt -> IF ( expr ) stmt .)
    ZEROS           reduce using rule 9 (stmt -> IF ( expr ) stmt .)
    ID              reduce using rule 9 (stmt -> IF ( expr ) stmt .)
    STRING          reduce using rule 9 (stmt -> IF ( expr ) stmt .)
    FLOAT           reduce using rule 9 (stmt -> IF ( expr ) stmt .)
    INT             reduce using rule 9 (stmt -> IF ( expr ) stmt .)
    -               reduce using rule 9 (stmt -> IF ( expr ) stmt .)
    [               reduce using rule 9 (stmt -> IF ( expr ) stmt .)
    $end            reduce using rule 9 (stmt -> IF ( expr ) stmt .)
    }               reduce using rule 9 (stmt -> IF ( expr ) stmt .)
    ELSE            shift and go to state 111


state 110

    (7) stmt -> FOR ID = expr : expr . stmt
    (30) expr -> expr . '
    (32) expr -> expr . GEQ expr
    (33) expr -> expr . LEQ expr
    (34) expr -> expr . > expr
    (35) expr -> expr . < expr
    (36) expr -> expr . NEQ expr
    (37) expr -> expr . EQ expr
    (38) expr -> expr . DOTDIV expr
    (39) expr -> expr . DOTMUL expr
    (40) expr -> expr . DOTSUB expr
    (41) expr -> expr . DOTADD expr
    (42) expr -> expr . / expr
    (43) expr -> expr . * expr
    (44) expr -> expr . - expr
    (45) expr -> expr . + expr
    (47) expr -> expr . [ expr_list ]
    (4) stmt -> . RETURN expr ;
    (5) stmt -> . CONTINUE ;
    (6) stmt -> . BREAK ;
    (7) stmt -> . FOR ID = expr : expr stmt
    (8) stmt -> . WHILE ( expr ) stmt
    (9) stmt -> . IF ( expr ) stmt
    (10) stmt -> . IF ( expr ) stmt ELSE stmt
    (11) stmt -> . PRINT expr_list ;
    (12) stmt -> . expr DIVASSIGN expr ;
    (13) stmt -> . expr MULASSIGN expr ;
    (14) stmt -> . expr SUBASSIGN expr ;
    (15) stmt -> . expr ADDASSIGN expr ;
    (16) stmt -> . expr = expr ;
    (17) stmt -> . expr ;
    (18) stmt -> . { }
    (19) stmt -> . { stmt_list }
    (22) expr -> . ( expr )
    (23) expr -> . EYE ( expr_list )
    (24) expr -> . ONES ( expr_list )
    (25) expr -> . ZEROS ( expr_list )
    (26) expr -> . ID
    (27) expr -> . STRING
    (28) expr -> . FLOAT
    (29) expr -> . INT
    (30) expr -> . expr '
    (31) expr -> . - expr
    (32) expr -> . expr GEQ expr
    (33) expr -> . expr LEQ expr
    (34) expr -> . expr > expr
    (35) expr -> . expr < expr
    (36) expr -> . expr NEQ expr
    (37) expr -> . expr EQ expr
    (38) expr -> . expr DOTDIV expr
    (39) expr -> . expr DOTMUL expr
    (40) expr -> . expr DOTSUB expr
    (41) expr -> . expr DOTADD expr
    (42) expr -> . expr / expr
    (43) expr -> . expr * expr
    (44) expr -> . expr - expr
    (45) expr -> . expr + expr
    (46) expr -> . [ expr_list ]
    (47) expr -> . expr [ expr_list ]
    '               shift and go to state 31
    GEQ             shift and go to state 32
    LEQ             shift and go to state 33
    >               shift and go to state 34
    <               shift and go to state 35
    NEQ             shift and go to state 36
    EQ              shift and go to state 37
    DOTDIV          shift and go to state 38
    DOTMUL          shift and go to state 39
    DOTSUB          shift and go to state 40
    DOTADD          shift and go to state 41
    /               shift and go to state 42
    *               shift and go to state 43
    -               shift and go to state 113
    +               shift and go to state 45
    [               shift and go to state 114
    RETURN          shift and go to state 4
    CONTINUE        shift and go to state 6
    BREAK           shift and go to state 7
    FOR             shift and go to state 8
    WHILE           shift and go to state 10
    IF              shift and go to state 12
    PRINT           shift and go to state 13
    {               shift and go to state 14
    (               shift and go to state 11
    EYE             shift and go to state 15
    ONES            shift and go to state 16
    ZEROS           shift and go to state 17
    ID              shift and go to state 9
    STRING          shift and go to state 18
    FLOAT           shift and go to state 19
    INT             shift and go to state 20

    expr                           shift and go to state 5
    stmt                           shift and go to state 112

state 111

    (10) stmt -> IF ( expr ) stmt ELSE . stmt
    (4) stmt -> . RETURN expr ;
    (5) stmt -> . CONTINUE ;
    (6) stmt -> . BREAK ;
    (7) stmt -> . FOR ID = expr : expr stmt
    (8) stmt -> . WHILE ( expr ) stmt
    (9) stmt -> . IF ( expr ) stmt
    (10) stmt -> . IF ( expr ) stmt ELSE stmt
    (11) stmt -> . PRINT expr_list ;
    (12) stmt -> . expr DIVASSIGN expr ;
    (13) stmt -> . expr MULASSIGN expr ;
    (14) stmt -> . expr SUBASSIGN expr ;
    (15) stmt -> . expr ADDASSIGN expr ;
    (16) stmt -> . expr = expr ;
    (17) stmt -> . expr ;
    (18) stmt -> . { }
    (19) stmt -> . { stmt_list }
    (22) expr -> . ( expr )
    (23) expr -> . EYE ( expr_list )
    (24) expr -> . ONES ( expr_list )
    (25) expr -> . ZEROS ( expr_list )
    (26) expr -> . ID
    (27) expr -> . STRING
    (28) expr -> . FLOAT
    (29) expr -> . INT
    (30) expr -> . expr '
    (31) expr -> . - expr
    (32) expr -> . expr GEQ expr
    (33) expr -> . expr LEQ expr
    (34) expr -> . expr > expr
    (35) expr -> . expr < expr
    (36) expr -> . expr NEQ expr
    (37) expr -> . expr EQ expr
    (38) expr -> . expr DOTDIV expr
    (39) expr -> . expr DOTMUL expr
    (40) expr -> . expr DOTSUB expr
    (41) expr -> . expr DOTADD expr
    (42) expr -> . expr / expr
    (43) expr -> . expr * expr
    (44) expr -> . expr - expr
    (45) expr -> . expr + expr
    (46) expr -> . [ expr_list ]
    (47) expr -> . expr [ expr_list ]
    RETURN          shift and go to state 4
    CONTINUE        shift and go to state 6
    BREAK           shift and go to state 7
    FOR             shift and go to state 8
    WHILE           shift and go to state 10
    IF              shift and go to state 12
    PRINT           shift and go to state 13
    {               shift and go to state 14
    (               shift and go to state 11
    EYE             shift and go to state 15
    ONES            shift and go to state 16
    ZEROS           shift and go to state 17
    ID              shift and go to state 9
    STRING          shift and go to state 18
    FLOAT           shift and go to state 19
    INT             shift and go to state 20
    -               shift and go to state 21
    [               shift and go to state 22

    expr                           shift and go to state 5
    stmt                           shift and go to state 115

state 112

    (7) stmt -> FOR ID = expr : expr stmt .
    RETURN          reduce using rule 7 (stmt -> FOR ID = expr : expr stmt .)
    CONTINUE        reduce using rule 7 (stmt -> FOR ID = expr : expr stmt .)
    BREAK           reduce using rule 7 (stmt -> FOR ID = expr : expr stmt .)
    FOR             reduce using rule 7 (stmt -> FOR ID = expr : expr stmt .)
    WHILE           reduce using rule 7 (stmt -> FOR ID = expr : expr stmt .)
    IF              reduce using rule 7 (stmt -> FOR ID = expr : expr stmt .)
    PRINT           reduce using rule 7 (stmt -> FOR ID = expr : expr stmt .)
    {               reduce using rule 7 (stmt -> FOR ID = expr : expr stmt .)
    (               reduce using rule 7 (stmt -> FOR ID = expr : expr stmt .)
    EYE             reduce using rule 7 (stmt -> FOR ID = expr : expr stmt .)
    ONES            reduce using rule 7 (stmt -> FOR ID = expr : expr stmt .)
    ZEROS           reduce using rule 7 (stmt -> FOR ID = expr : expr stmt .)
    ID              reduce using rule 7 (stmt -> FOR ID = expr : expr stmt .)
    STRING          reduce using rule 7 (stmt -> FOR ID = expr : expr stmt .)
    FLOAT           reduce using rule 7 (stmt -> FOR ID = expr : expr stmt .)
    INT             reduce using rule 7 (stmt -> FOR ID = expr : expr stmt .)
    -               reduce using rule 7 (stmt -> FOR ID = expr : expr stmt .)
    [               reduce using rule 7 (stmt -> FOR ID = expr : expr stmt .)
    $end            reduce using rule 7 (stmt -> FOR ID = expr : expr stmt .)
    }               reduce using rule 7 (stmt -> FOR ID = expr : expr stmt .)
    ELSE            reduce using rule 7 (stmt -> FOR ID = expr : expr stmt .)


state 113

    (44) expr -> expr - . expr
    (31) expr -> - . expr
    (22) expr -> . ( expr )
    (23) expr -> . EYE ( expr_list )
    (24) expr -> . ONES ( expr_list )
    (25) expr -> . ZEROS ( expr_list )
    (26) expr -> . ID
    (27) expr -> . STRING
    (28) expr -> . FLOAT
    (29) expr -> . INT
    (30) expr -> . expr '
    (31) expr -> . - expr
    (32) expr -> . expr GEQ expr
    (33) expr -> . expr LEQ expr
    (34) expr -> . expr > expr
    (35) expr -> . expr < expr
    (36) expr -> . expr NEQ expr
    (37) expr -> . expr EQ expr
    (38) expr -> . expr DOTDIV expr
    (39) expr -> . expr DOTMUL expr
    (40) expr -> . expr DOTSUB expr
    (41) expr -> . expr DOTADD expr
    (42) expr -> . expr / expr
    (43) expr -> . expr * expr
    (44) expr -> . expr - expr
    (45) expr -> . expr + expr
    (46) expr -> . [ expr_list ]
    (47) expr -> . expr [ expr_list ]
    (               shift and go to state 11
    EYE             shift and go to state 15
    ONES            shift and go to state 16
    ZEROS           shift and go to state 17
    ID              shift and go to state 9
    STRING          shift and go to state 18
    FLOAT           shift and go to state 19
    INT             shift and go to state 20
    -               shift and go to state 21
    [               shift and go to state 22

    expr                           shift and go to state 116

state 114

    (47) expr -> expr [ . expr_list ]
    (46) expr -> [ . expr_list ]
    (20) expr_list -> . expr
    (21) expr_list -> . expr , expr_list
    (22) expr -> . ( expr )
    (23) expr -> . EYE ( expr_list )
    (24) expr -> . ONES ( expr_list )
    (25) expr -> . ZEROS ( expr_list )
    (26) expr -> . ID
    (27) expr -> . STRING
    (28) expr -> . FLOAT
    (29) expr -> . INT
    (30) expr -> . expr '
    (31) expr -> . - expr
    (32) expr -> . expr GEQ expr
    (33) expr -> . expr LEQ expr
    (34) expr -> . expr > expr
    (35) expr -> . expr < expr
    (36) expr -> . expr NEQ expr
    (37) expr -> . expr EQ expr
    (38) expr -> . expr DOTDIV expr
    (39) expr -> . expr DOTMUL expr
    (40) expr -> . expr DOTSUB expr
    (41) expr -> . expr DOTADD expr
    (42) expr -> . expr / expr
    (43) expr -> . expr * expr
    (44) expr -> . expr - expr
    (45) expr -> . expr + expr
    (46) expr -> . [ expr_list ]
    (47) expr -> . expr [ expr_list ]
    (               shift and go to state 11
    EYE             shift and go to state 15
    ONES            shift and go to state 16
    ZEROS           shift and go to state 17
    ID              shift and go to state 9
    STRING          shift and go to state 18
    FLOAT           shift and go to state 19
    INT             shift and go to state 20
    -               shift and go to state 21
    [               shift and go to state 22

    expr                           shift and go to state 54
    expr_list                      shift and go to state 117

state 115

    (10) stmt -> IF ( expr ) stmt ELSE stmt .
    RETURN          reduce using rule 10 (stmt -> IF ( expr ) stmt ELSE stmt .)
    CONTINUE        reduce using rule 10 (stmt -> IF ( expr ) stmt ELSE stmt .)
    BREAK           reduce using rule 10 (stmt -> IF ( expr ) stmt ELSE stmt .)
    FOR             reduce using rule 10 (stmt -> IF ( expr ) stmt ELSE stmt .)
    WHILE           reduce using rule 10 (stmt -> IF ( expr ) stmt ELSE stmt .)
    IF              reduce using rule 10 (stmt -> IF ( expr ) stmt ELSE stmt .)
    PRINT           reduce using rule 10 (stmt -> IF ( expr ) stmt ELSE stmt .)
    {               reduce using rule 10 (stmt -> IF ( expr ) stmt ELSE stmt .)
    (               reduce using rule 10 (stmt -> IF ( expr ) stmt ELSE stmt .)
    EYE             reduce using rule 10 (stmt -> IF ( expr ) stmt ELSE stmt .)
    ONES            reduce using rule 10 (stmt -> IF ( expr ) stmt ELSE stmt .)
    ZEROS           reduce using rule 10 (stmt -> IF ( expr ) stmt ELSE stmt .)
    ID              reduce using rule 10 (stmt -> IF ( expr ) stmt ELSE stmt .)
    STRING          reduce using rule 10 (stmt -> IF ( expr ) stmt ELSE stmt .)
    FLOAT           reduce using rule 10 (stmt -> IF ( expr ) stmt ELSE stmt .)
    INT             reduce using rule 10 (stmt -> IF ( expr ) stmt ELSE stmt .)
    -               reduce using rule 10 (stmt -> IF ( expr ) stmt ELSE stmt .)
    [               reduce using rule 10 (stmt -> IF ( expr ) stmt ELSE stmt .)
    $end            reduce using rule 10 (stmt -> IF ( expr ) stmt ELSE stmt .)
    }               reduce using rule 10 (stmt -> IF ( expr ) stmt ELSE stmt .)
    ELSE            reduce using rule 10 (stmt -> IF ( expr ) stmt ELSE stmt .)


state 116

    (44) expr -> expr - expr .
    (31) expr -> - expr .
    (30) expr -> expr . '
    (32) expr -> expr . GEQ expr
    (33) expr -> expr . LEQ expr
    (34) expr -> expr . > expr
    (35) expr -> expr . < expr
    (36) expr -> expr . NEQ expr
    (37) expr -> expr . EQ expr
    (38) expr -> expr . DOTDIV expr
    (39) expr -> expr . DOTMUL expr
    (40) expr -> expr . DOTSUB expr
    (41) expr -> expr . DOTADD expr
    (42) expr -> expr . / expr
    (43) expr -> expr . * expr
    (44) expr -> expr . - expr
    (45) expr -> expr . + expr
    (47) expr -> expr . [ expr_list ]
  ! reduce/reduce conflict for ' resolved using rule 44 (expr -> expr - expr .)
  ! reduce/reduce conflict for GEQ resolved using rule 44 (expr -> expr - expr .)
  ! reduce/reduce conflict for LEQ resolved using rule 44 (expr -> expr - expr .)
  ! reduce/reduce conflict for > resolved using rule 44 (expr -> expr - expr .)
  ! reduce/reduce conflict for < resolved using rule 44 (expr -> expr - expr .)
  ! reduce/reduce conflict for NEQ resolved using rule 44 (expr -> expr - expr .)
  ! reduce/reduce conflict for EQ resolved using rule 44 (expr -> expr - expr .)
  ! reduce/reduce conflict for DOTDIV resolved using rule 44 (expr -> expr - expr .)
  ! reduce/reduce conflict for DOTMUL resolved using rule 44 (expr -> expr - expr .)
  ! reduce/reduce conflict for DOTSUB resolved using rule 44 (expr -> expr - expr .)
  ! reduce/reduce conflict for DOTADD resolved using rule 44 (expr -> expr - expr .)
  ! reduce/reduce conflict for / resolved using rule 44 (expr -> expr - expr .)
  ! reduce/reduce conflict for * resolved using rule 44 (expr -> expr - expr .)
  ! reduce/reduce conflict for - resolved using rule 44 (expr -> expr - expr .)
  ! reduce/reduce conflict for + resolved using rule 44 (expr -> expr - expr .)
  ! reduce/reduce conflict for [ resolved using rule 44 (expr -> expr - expr .)
    '               reduce using rule 44 (expr -> expr - expr .)
    GEQ             reduce using rule 44 (expr -> expr - expr .)
    LEQ             reduce using rule 44 (expr -> expr - expr .)
    >               reduce using rule 44 (expr -> expr - expr .)
    <               reduce using rule 44 (expr -> expr - expr .)
    NEQ             reduce using rule 44 (expr -> expr - expr .)
    EQ              reduce using rule 44 (expr -> expr - expr .)
    DOTSUB          reduce using rule 44 (expr -> expr - expr .)
    DOTADD          reduce using rule 44 (expr -> expr - expr .)
    -               reduce using rule 44 (expr -> expr - expr .)
    +               reduce using rule 44 (expr -> expr - expr .)
    [               reduce using rule 44 (expr -> expr - expr .)
    RETURN          reduce using rule 44 (expr -> expr - expr .)
    CONTINUE        reduce using rule 44 (expr -> expr - expr .)
    BREAK           reduce using rule 44 (expr -> expr - expr .)
    FOR             reduce using rule 44 (expr -> expr - expr .)
    WHILE           reduce using rule 44 (expr -> expr - expr .)
    IF              reduce using rule 44 (expr -> expr - expr .)
    PRINT           reduce using rule 44 (expr -> expr - expr .)
    {               reduce using rule 44 (expr -> expr - expr .)
    (               reduce using rule 44 (expr -> expr - expr .)
    EYE             reduce using rule 44 (expr -> expr - expr .)
    ONES            reduce using rule 44 (expr -> expr - expr .)
    ZEROS           reduce using rule 44 (expr -> expr - expr .)
    ID              reduce using rule 44 (expr -> expr - expr .)
    STRING          reduce using rule 44 (expr -> expr - expr .)
    FLOAT           reduce using rule 44 (expr -> expr - expr .)
    INT             reduce using rule 44 (expr -> expr - expr .)
    DIVASSIGN       reduce using rule 31 (expr -> - expr .)
    MULASSIGN       reduce using rule 31 (expr -> - expr .)
    SUBASSIGN       reduce using rule 31 (expr -> - expr .)
    ADDASSIGN       reduce using rule 31 (expr -> - expr .)
    =               reduce using rule 31 (expr -> - expr .)
    ;               reduce using rule 31 (expr -> - expr .)
    DOTDIV          shift and go to state 38
    DOTMUL          shift and go to state 39
    /               shift and go to state 42
    *               shift and go to state 43


state 117

    (47) expr -> expr [ expr_list . ]
    (46) expr -> [ expr_list . ]
    ]               shift and go to state 118


state 118

    (47) expr -> expr [ expr_list ] .
    (46) expr -> [ expr_list ] .
  ! reduce/reduce conflict for ' resolved using rule 47 (expr -> expr [ expr_list ] .)
  ! reduce/reduce conflict for GEQ resolved using rule 47 (expr -> expr [ expr_list ] .)
  ! reduce/reduce conflict for LEQ resolved using rule 47 (expr -> expr [ expr_list ] .)
  ! reduce/reduce conflict for > resolved using rule 47 (expr -> expr [ expr_list ] .)
  ! reduce/reduce conflict for < resolved using rule 47 (expr -> expr [ expr_list ] .)
  ! reduce/reduce conflict for NEQ resolved using rule 47 (expr -> expr [ expr_list ] .)
  ! reduce/reduce conflict for EQ resolved using rule 47 (expr -> expr [ expr_list ] .)
  ! reduce/reduce conflict for DOTDIV resolved using rule 47 (expr -> expr [ expr_list ] .)
  ! reduce/reduce conflict for DOTMUL resolved using rule 47 (expr -> expr [ expr_list ] .)
  ! reduce/reduce conflict for DOTSUB resolved using rule 47 (expr -> expr [ expr_list ] .)
  ! reduce/reduce conflict for DOTADD resolved using rule 47 (expr -> expr [ expr_list ] .)
  ! reduce/reduce conflict for / resolved using rule 47 (expr -> expr [ expr_list ] .)
  ! reduce/reduce conflict for * resolved using rule 47 (expr -> expr [ expr_list ] .)
  ! reduce/reduce conflict for - resolved using rule 47 (expr -> expr [ expr_list ] .)
  ! reduce/reduce conflict for + resolved using rule 47 (expr -> expr [ expr_list ] .)
  ! reduce/reduce conflict for [ resolved using rule 47 (expr -> expr [ expr_list ] .)
    '               reduce using rule 47 (expr -> expr [ expr_list ] .)
    GEQ             reduce using rule 47 (expr -> expr [ expr_list ] .)
    LEQ             reduce using rule 47 (expr -> expr [ expr_list ] .)
    >               reduce using rule 47 (expr -> expr [ expr_list ] .)
    <               reduce using rule 47 (expr -> expr [ expr_list ] .)
    NEQ             reduce using rule 47 (expr -> expr [ expr_list ] .)
    EQ              reduce using rule 47 (expr -> expr [ expr_list ] .)
    DOTDIV          reduce using rule 47 (expr -> expr [ expr_list ] .)
    DOTMUL          reduce using rule 47 (expr -> expr [ expr_list ] .)
    DOTSUB          reduce using rule 47 (expr -> expr [ expr_list ] .)
    DOTADD          reduce using rule 47 (expr -> expr [ expr_list ] .)
    /               reduce using rule 47 (expr -> expr [ expr_list ] .)
    *               reduce using rule 47 (expr -> expr [ expr_list ] .)
    -               reduce using rule 47 (expr -> expr [ expr_list ] .)
    +               reduce using rule 47 (expr -> expr [ expr_list ] .)
    [               reduce using rule 47 (expr -> expr [ expr_list ] .)
    RETURN          reduce using rule 47 (expr -> expr [ expr_list ] .)
    CONTINUE        reduce using rule 47 (expr -> expr [ expr_list ] .)
    BREAK           reduce using rule 47 (expr -> expr [ expr_list ] .)
    FOR             reduce using rule 47 (expr -> expr [ expr_list ] .)
    WHILE           reduce using rule 47 (expr -> expr [ expr_list ] .)
    IF              reduce using rule 47 (expr -> expr [ expr_list ] .)
    PRINT           reduce using rule 47 (expr -> expr [ expr_list ] .)
    {               reduce using rule 47 (expr -> expr [ expr_list ] .)
    (               reduce using rule 47 (expr -> expr [ expr_list ] .)
    EYE             reduce using rule 47 (expr -> expr [ expr_list ] .)
    ONES            reduce using rule 47 (expr -> expr [ expr_list ] .)
    ZEROS           reduce using rule 47 (expr -> expr [ expr_list ] .)
    ID              reduce using rule 47 (expr -> expr [ expr_list ] .)
    STRING          reduce using rule 47 (expr -> expr [ expr_list ] .)
    FLOAT           reduce using rule 47 (expr -> expr [ expr_list ] .)
    INT             reduce using rule 47 (expr -> expr [ expr_list ] .)
    DIVASSIGN       reduce using rule 46 (expr -> [ expr_list ] .)
    MULASSIGN       reduce using rule 46 (expr -> [ expr_list ] .)
    SUBASSIGN       reduce using rule 46 (expr -> [ expr_list ] .)
    ADDASSIGN       reduce using rule 46 (expr -> [ expr_list ] .)
    =               reduce using rule 46 (expr -> [ expr_list ] .)
    ;               reduce using rule 46 (expr -> [ expr_list ] .)


Conflicts:

reduce/reduce conflict in state 116 resolved using rule expr -> expr - expr  [precedence=left, level=4]
rejected rule (expr -> - expr  [precedence=left, level=5]) in state 116
reduce/reduce conflict in state 118 resolved using rule expr -> expr [ expr_list ]
rejected rule (expr -> [ expr_list ]) in state 118